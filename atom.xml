<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>缺陷代码</title>
  
  <subtitle>生活不止有眼前的苟且，还有诗和远方...</subtitle>
  <link href="https://groupfusion.github.io/atom.xml" rel="self"/>
  
  <link href="https://groupfusion.github.io/"/>
  <updated>2024-01-10T05:21:05.602Z</updated>
  <id>https://groupfusion.github.io/</id>
  
  <author>
    <name>xmon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis bind ip 连接认证及bind的注意事项</title>
    <link href="https://groupfusion.github.io/2024/01/10/dev/redis_bind%E8%AE%BE%E7%BD%AE/"/>
    <id>https://groupfusion.github.io/2024/01/10/dev/redis_bind%E8%AE%BE%E7%BD%AE/</id>
    <published>2024-01-10T07:41:20.000Z</published>
    <updated>2024-01-10T05:21:05.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开启保护模式-默认开启"><a href="#开启保护模式-默认开启" class="headerlink" title="开启保护模式(默认开启)"></a>开启保护模式(默认开启)</h2><p>设置 protected-mode 为 yes</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Protected mode is a layer of security protection, in order to avoid that</span><br><span class="line"># Redis instances left open on the internet are accessed and exploited.</span><br><span class="line"># 保护模式是一层安全保护，以避免在互联网上打开的Redis实例会被访问和利用。</span><br><span class="line"># </span><br><span class="line"># When protected mode is on and if:</span><br><span class="line"># 当保护模式打开时，如果：</span><br><span class="line"># </span><br><span class="line"># 1) The server is not binding explicitly to a set of addresses using the</span><br><span class="line">#    &quot;bind&quot; directive.</span><br><span class="line">#    服务器未使用“bind”指令显式绑定到一组地址。</span><br><span class="line"># 2) No password is configured.</span><br><span class="line">#    未配置密码。</span><br><span class="line"># </span><br><span class="line"># The server only accepts connections from clients connecting from the</span><br><span class="line"># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span><br><span class="line"># sockets.</span><br><span class="line"># 服务器只接受来自从IPv4 和 IPv6 环回地址 127.0.0.1 和::1，以及来自 Unix 域sockets客户端的连接。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果开启了保护模式，并且bind未配置，密码也未设置。redis只接受来自本机的连接。</p><h2 id="bind地址设置"><a href="#bind地址设置" class="headerlink" title="bind地址设置"></a>bind地址设置</h2><p>对于bind，不少人都误解了。以为这个设置是只对客户端IP的连接限制，其实这是错误的！错误的！错误的！bind是你服务器的IP地址！</p><p>比如我的虚拟机有三个网卡：<br>地址分别为192.168.1.5，192.168.1.6，192.168.1.9</p><p>bind只能是0.0.0.0和这三个网卡地址，除了这四个IP，其它任何IP都会报错。</p><ul><li><p>当设置bind为 0.0.0.0 时，通过任意三个网卡都能连接redis:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure></li><li><p>当设置bind为 192.168.1.9 时,通过另外两个网卡都不能连接redis:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.1.9</span><br></pre></td></tr></table></figure><p>bind 192.168.1.9. 只有我们通过192.168.1.9来访问redis服务器，才允许连接Redis服务器，如果我们通过192.168.1.5、192.168.1.6来访问Redis服务器，就会连不上Redis。</p></li><li><p>这里设置所有ip都可以访问，包括所有ipv6都可以访问.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind * -::*</span><br></pre></td></tr></table></figure></li><li><p>当设置bind为 127.0.0.1 ::1 时，只能本机访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1 ::1</span><br></pre></td></tr></table></figure></li></ul><p>所以bind不是针对远程客户端的IP，而是服务器的网卡IP，远程客户端通过服务器的网卡地址来连接redis</p><h2 id="设置访问密码：requirepass"><a href="#设置访问密码：requirepass" class="headerlink" title="设置访问密码：requirepass"></a>设置访问密码：requirepass</h2><p>设置连接密码，客户端连接时，需要密码认证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</span><br><span class="line"># commands.  This might be useful in environments in which you do not trust</span><br><span class="line"># others with access to the host running redis-server.</span><br><span class="line"># 要求客户端在处理任何其他指令之前发出AUTH &lt;PASSWORD&gt;命令。这在您不信任他人访问运行redis服务器的主机的环境中可能很有用。</span><br><span class="line"># This should stay commented out for backward compatibility and because most</span><br><span class="line"># people do not need auth (e.g. they run their own servers).</span><br><span class="line"># 出于向后兼容性的考虑，并且大多数人不需要身份验证（例如，他们运行自己的服务器），这里应该保持注释掉。</span><br><span class="line">#</span><br><span class="line"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="line"># 150k passwords per second against a good box. This means that you should</span><br><span class="line"># use a very strong password otherwise it will be very easy to break.</span><br><span class="line"># 警告：由于 Redis 速度非常快，外部用户可以尝试以每秒 150k 密码破解。这意味着您应该使用非常强的密码，否则很容易被破解。</span><br><span class="line">#</span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\Redis-cluster&gt;redis-cli -h 192.168.1.9</span><br><span class="line">192.168.1.9:6379&gt; keys *</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">192.168.1.9:6379&gt; auth 123456</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开启保护模式-默认开启&quot;&gt;&lt;a href=&quot;#开启保护模式-默认开启&quot; class=&quot;headerlink&quot; title=&quot;开启保护模式(默认开启)&quot;&gt;&lt;/a&gt;开启保护模式(默认开启)&lt;/h2&gt;&lt;p&gt;设置 protected-mode 为 yes&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://groupfusion.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis错误：Could not create server TCP listening socket * :6379： 不知道这样的主机。</title>
    <link href="https://groupfusion.github.io/2024/01/10/dev/Redis%E9%94%99%E8%AF%AF-%E4%B8%8D%E7%9F%A5%E9%81%93%E8%BF%99%E6%A0%B7%E7%9A%84%E4%B8%BB%E6%9C%BA/"/>
    <id>https://groupfusion.github.io/2024/01/10/dev/Redis%E9%94%99%E8%AF%AF-%E4%B8%8D%E7%9F%A5%E9%81%93%E8%BF%99%E6%A0%B7%E7%9A%84%E4%B8%BB%E6%9C%BA/</id>
    <published>2024-01-10T07:41:20.000Z</published>
    <updated>2024-01-10T05:20:54.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis错误：Could-not-create-server-TCP-listening-socket-6379-不知道这样的主机。"><a href="#Redis错误：Could-not-create-server-TCP-listening-socket-6379-不知道这样的主机。" class="headerlink" title="Redis错误：Could not create server TCP listening socket * :6379: 不知道这样的主机。"></a>Redis错误：Could not create server TCP listening socket * :6379: 不知道这样的主机。</h1><h2 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h2><p>redis服务在window下启动时，报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\server\Redis&gt;redis-server redis.windows.conf</span><br><span class="line">[30268] 10 Jan 10:24:57.196 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">[30268] 10 Jan 10:24:57.197 <span class="comment"># Redis version=5.0.14, bits=64, commit=a7c01ef4, modified=0, pid=30268, just started</span></span><br><span class="line">[30268] 10 Jan 10:24:57.197 <span class="comment"># Configuration loaded</span></span><br><span class="line">[30268] 10 Jan 10:24:57.200 <span class="comment"># Could not create server TCP listening socket *:6379: 不知道这样的主机。</span></span><br></pre></td></tr></table></figure><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>redis bind 地址设置导致的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#这里设置所有ip都可以访问，包括所有ipv6都可以访问</span><br><span class="line">bind * -::*</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>redis 修改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#当设置bind为 0.0.0.0时，通过任意三个网卡都能连接redis:</span><br><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure><p>然后启动redis服务：redis-server.exe redis.windows.conf</p><p>注：这个问题是对redis.conf配置不熟悉导致的。关于bind配置详见<a href="./redis_bind%E8%AE%BE%E7%BD%AE.md">&lt;redis bind设置&gt;</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis错误：Could-not-create-server-TCP-listening-socket-6379-不知道这样的主机。&quot;&gt;&lt;a href=&quot;#Redis错误：Could-not-create-server-TCP-listening-socket-</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://groupfusion.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 + element-plus + I18n 国际化</title>
    <link href="https://groupfusion.github.io/2024/01/09/devlang/vue/vue3+element-plus%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    <id>https://groupfusion.github.io/2024/01/09/devlang/vue/vue3+element-plus%E5%9B%BD%E9%99%85%E5%8C%96/</id>
    <published>2024-01-09T11:47:57.000Z</published>
    <updated>2024-01-10T05:38:56.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录项目中集成i18n实现国际化，特在此记录，便于日后浏览。</p><h2 id="组件库国际化方案"><a href="#组件库国际化方案" class="headerlink" title="组件库国际化方案"></a>组件库国际化方案</h2><ul><li>vue3</li><li>ElementPlus</li><li>vue-i18n</li></ul><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-i18n</span><br></pre></td></tr></table></figure><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><h3 id="1-新建index-ts-新建文件路径src-locales目录下"><a href="#1-新建index-ts-新建文件路径src-locales目录下" class="headerlink" title="1. 新建index.ts,新建文件路径src/locales目录下"></a>1. 新建index.ts,新建文件路径src/locales目录下</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createI18n &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-i18n&#x27;</span></span><br><span class="line"><span class="comment">// 语言包</span></span><br><span class="line"><span class="keyword">import</span> zhCN <span class="keyword">from</span> <span class="string">&quot;./lang/zh-CN&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> enUS <span class="keyword">from</span> <span class="string">&quot;./lang/en-US&quot;</span>;</span><br><span class="line"><span class="comment">// 设置默认语言</span></span><br><span class="line"><span class="keyword">const</span> locale = <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;language&#x27;</span>) || <span class="string">&#x27;zhCN&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册i8n实例并引入语言文件</span></span><br><span class="line"><span class="keyword">const</span> i18n = createI18n(&#123;</span><br><span class="line">  <span class="attr">global</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">locale</span>: locale,</span><br><span class="line">  <span class="attr">fallbackLocale</span>: locale, <span class="comment">// 默认语言</span></span><br><span class="line">  <span class="attr">messages</span>: &#123;</span><br><span class="line">    zhCN,</span><br><span class="line">    enUS,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> i18n</span><br></pre></td></tr></table></figure><h3 id="2-新建zh-CN-ts，存放中文，存放在src-locales-lang"><a href="#2-新建zh-CN-ts，存放中文，存放在src-locales-lang" class="headerlink" title="2.新建zh-CN.ts，存放中文，存放在src/locales/lang/"></a>2.新建zh-CN.ts，存放中文，存放在src/locales/lang/</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">login</span>:&#123;</span><br><span class="line">        <span class="attr">title</span>:<span class="string">&quot;后台管理系统&quot;</span>,</span><br><span class="line">        <span class="attr">username</span>:<span class="string">&quot;账号&quot;</span>,</span><br><span class="line">        <span class="attr">password</span>:<span class="string">&quot;密码&quot;</span>,</span><br><span class="line">        <span class="attr">code</span>:<span class="string">&quot;验证码&quot;</span>,</span><br><span class="line">        <span class="attr">rememberMe</span>:<span class="string">&quot;记住密码&quot;</span>,</span><br><span class="line">        <span class="attr">btn_login</span>:<span class="string">&quot;登 录&quot;</span>,</span><br><span class="line">        <span class="attr">btn_logining</span>:<span class="string">&quot;登 录 中...&quot;</span>,</span><br><span class="line">        <span class="attr">link_register</span>:<span class="string">&quot;立即注册&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-新建en-US-js，存放英文，存放在src-locales-lang"><a href="#3-新建en-US-js，存放英文，存放在src-locales-lang" class="headerlink" title="3.新建en-US.js，存放英文，存放在src/locales/lang/"></a>3.新建en-US.js，存放英文，存放在src/locales/lang/</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">login</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;Kola Management System&quot;</span>,</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&quot;username&quot;</span>,</span><br><span class="line">        <span class="attr">password</span>: <span class="string">&quot;password&quot;</span>,</span><br><span class="line">        <span class="attr">code</span>: <span class="string">&quot;code&quot;</span>,</span><br><span class="line">        <span class="attr">rememberMe</span>: <span class="string">&quot;rememberMe&quot;</span>,</span><br><span class="line">        <span class="attr">btn_login</span>: <span class="string">&quot;login&quot;</span>,</span><br><span class="line">        <span class="attr">btn_logining</span>:<span class="string">&quot;logining...&quot;</span>,</span><br><span class="line">        <span class="attr">link_register</span>:<span class="string">&quot;register&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1-在main-ts里引入并挂载到实例上"><a href="#1-在main-ts里引入并挂载到实例上" class="headerlink" title="1.在main.ts里引入并挂载到实例上"></a>1.在main.ts里引入并挂载到实例上</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;@/App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> i18n <span class="keyword">from</span> <span class="string">&#x27;@/locales/index&#x27;</span></span><br><span class="line"></span><br><span class="line">createApp(App).use(i18n).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-在组件内部template内使用"><a href="#2-在组件内部template内使用" class="headerlink" title="2.在组件内部template内使用"></a>2.在组件内部template内使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;login&quot;&gt;</span><br><span class="line">    &lt;el-form ref=&quot;loginRef&quot; :model=&quot;loginForm&quot; :rules=&quot;loginRules&quot; class=&quot;login-form&quot;&gt;</span><br><span class="line">      //组件内的模板</span><br><span class="line">      &lt;h3 class=&quot;title&quot;&gt;&#123;&#123;`$t(&#x27;login.title&#x27;)`&#125;&#125;&lt;/h3&gt;</span><br><span class="line">      &lt;el-form-item prop=&quot;username&quot;&gt;</span><br><span class="line">      // 动态绑定在vue</span><br><span class="line">        &lt;el-input</span><br><span class="line">          v-model=&quot;loginForm.username&quot;</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          size=&quot;large&quot;</span><br><span class="line">          auto-complete=&quot;off&quot;</span><br><span class="line">          :placeholder=&quot;`$t(&#x27;login.username&#x27;)`&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;template #prefix&gt;&lt;svg-icon icon-class=&quot;user&quot; class=&quot;el-input__icon input-icon&quot; /&gt;&lt;/template&gt;</span><br><span class="line">        &lt;/el-input&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item prop=&quot;password&quot;&gt;</span><br><span class="line">      // 动态绑定在vue</span><br><span class="line">        &lt;el-input</span><br><span class="line">          v-model=&quot;loginForm.password&quot;</span><br><span class="line">          type=&quot;password&quot;</span><br><span class="line">          size=&quot;large&quot;</span><br><span class="line">          auto-complete=&quot;off&quot;</span><br><span class="line">          :placeholder=&quot;`$t(&#x27;login.password&#x27;)`&quot;</span><br><span class="line">          @keyup.enter=&quot;handleLogin&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;template #prefix&gt;&lt;svg-icon icon-class=&quot;password&quot; class=&quot;el-input__icon input-icon&quot; /&gt;&lt;/template&gt;</span><br><span class="line">        &lt;/el-input&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item prop=&quot;code&quot; v-if=&quot;captchaEnabled&quot;&gt;</span><br><span class="line">      // 动态绑定在vue</span><br><span class="line">        &lt;el-input</span><br><span class="line">          v-model=&quot;loginForm.code&quot;</span><br><span class="line">          size=&quot;large&quot;</span><br><span class="line">          auto-complete=&quot;off&quot;</span><br><span class="line">          :placeholder=&quot;`$t(&#x27;login.code&#x27;)`&quot;</span><br><span class="line">          style=&quot;width: 63%&quot;</span><br><span class="line">          @keyup.enter=&quot;handleLogin&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;template #prefix&gt;&lt;svg-icon icon-class=&quot;validCode&quot; class=&quot;el-input__icon input-icon&quot; /&gt;&lt;/template&gt;</span><br><span class="line">        &lt;/el-input&gt;</span><br><span class="line">        &lt;div class=&quot;login-code&quot;&gt;</span><br><span class="line">          &lt;img :src=&quot;codeUrl&quot; @click=&quot;getCode&quot; class=&quot;login-code-img&quot;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-checkbox v-model=&quot;loginForm.rememberMe&quot; style=&quot;margin:0px 0px 25px 0px;&quot;&gt;&#123;&#123;`$t(&#x27;login.rememberMe&#x27;)`&#125;&#125;&lt;/el-checkbox&gt;</span><br><span class="line">      &lt;el-form-item style=&quot;width:100%;&quot;&gt;</span><br><span class="line">        &lt;el-button</span><br><span class="line">          :loading=&quot;loading&quot;</span><br><span class="line">          size=&quot;large&quot;</span><br><span class="line">          type=&quot;primary&quot;</span><br><span class="line">          style=&quot;width:100%;&quot;</span><br><span class="line">          @click.prevent=&quot;handleLogin&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;span v-if=&quot;!loading&quot;&gt;&#123;&#123;`$t(&#x27;login.btn_login&#x27;)`&#125;&#125;&lt;/span&gt;</span><br><span class="line">          &lt;span v-else&gt;&#123;&#123;`$t(&#x27;login.btn_logining&#x27;)`&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/el-button&gt;</span><br><span class="line">        </span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">    &lt;/el-form&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在el-input中要加入placeholder的值时 $t(‘login.username’) 要使用:placeholder. 示例如下<br>:placeholder=”$t(‘login.username’)”</p><p>//组件内的模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$t(&#x27;login.rememberMe&#x27;)</span><br></pre></td></tr></table></figure><h2 id="语言切换"><a href="#语言切换" class="headerlink" title="语言切换"></a>语言切换</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-dropdown</span> <span class="attr">trigger</span>=<span class="string">&quot;click&quot;</span> @<span class="attr">command</span>=<span class="string">&quot;handleChangeLanguage&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;language-icon--style&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">svg-icon</span> <span class="attr">class-name</span>=<span class="string">&quot;language-icon&quot;</span> <span class="attr">icon-class</span>=<span class="string">&quot;language&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> #<span class="attr">dropdown</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-dropdown-menu</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-dropdown-item</span></span></span><br><span class="line"><span class="tag">            <span class="attr">v-for</span>=<span class="string">&quot;item of languageOptions&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:key</span>=<span class="string">&quot;item.value&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:disabled</span>=<span class="string">&quot;langugae === item.value&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:command</span>=<span class="string">&quot;item.value&quot;</span></span></span><br><span class="line"><span class="tag">          &gt;</span></span><br><span class="line">            &#123;&#123; item.label &#125;&#125;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">el-dropdown-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-dropdown-menu</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-dropdown</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; computed, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> langugae = computed(<span class="function">() =&gt;</span> <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;language&#x27;</span>));</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> languageOptions = ref([</span></span><br><span class="line"><span class="javascript">  &#123; <span class="attr">label</span>: <span class="string">&quot;English&quot;</span>, <span class="attr">value</span>: <span class="string">&quot;enUS&quot;</span> &#125;,</span></span><br><span class="line"><span class="javascript">  &#123; <span class="attr">label</span>: <span class="string">&quot;中文&quot;</span>, <span class="attr">value</span>: <span class="string">&quot;zhCN&quot;</span> &#125;,</span></span><br><span class="line"><span class="javascript">]);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">handleChangeLanguage</span>(<span class="params">langugae: any</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">localStorage</span>.setItem(langugae);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">setTimeout</span>(<span class="string">&quot;window.location.reload()&quot;</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.language-icon--style</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文记录项目中集成i18n实现国际化，特在此记录，便于日后浏览。&lt;/p&gt;
&lt;h2 id=&quot;组件库国际化方案&quot;&gt;&lt;a href=&quot;#组件库国际</summary>
      
    
    
    
    
    <category term="Vue3" scheme="https://groupfusion.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>如何做技术规划</title>
    <link href="https://groupfusion.github.io/2024/01/05/dev/%E5%A6%82%E4%BD%95%E5%81%9A%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/"/>
    <id>https://groupfusion.github.io/2024/01/05/dev/%E5%A6%82%E4%BD%95%E5%81%9A%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/</id>
    <published>2024-01-05T07:41:20.000Z</published>
    <updated>2024-01-05T01:26:11.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何做技术规划"><a href="#如何做技术规划" class="headerlink" title="如何做技术规划?"></a>如何做技术规划?</h2><p>整理自<a href="https://www.bilibili.com/video/BV1bG411r7G3">如何做技术规划?</a></p><h3 id="为什么要做技术规划"><a href="#为什么要做技术规划" class="headerlink" title="为什么要做技术规划?"></a>为什么要做技术规划?</h3><p>资源是有限的，一个技术团队不可能同时做好所有事，必须面对选择，作为tech leader，为团队选择最有价值的工作才能使得整体收益最大化，无论团队还是个人都<strong>不能仅靠case/问题驱动去解决问题</strong>，这样做只会让团队或者自己辛苦一年而无产出，浪费业务资源，结果跑偏，影响业务发展。</p><p>对个人来说，这也是一个极其重要的能力，<strong>新手能把事情做对，高手要去做对的事情,而技术规划能力则是其中最重要的分水岭</strong>。</p><p>对于团队来说，tech eader 需要尽可能的打造一个技术上领先的团队去应对业务的发展，<strong>使得技术本身作为业务的核心竞争力</strong>,在稳定性/送代效率与质量/安全性/架构先进性上等等技术方面超越业界水平。</p><h3 id="什么是技术规划"><a href="#什么是技术规划" class="headerlink" title="什么是技术规划"></a>什么是技术规划</h3><p>技术规划不仅是产出计划书或技术方案，更是对最终愿景的思考过程，<strong>着重在战略</strong>，而非战术。</p><p>做技术规划不能仅把过去遗留的问题，项目集合罗列出来，形成一个超级巨大的一年期的TODO list，这是一件很丢人的事情。</p><p>技术规划要抽象问题，发现本质原因，整体性，方向性，战略性的描述解决方案，所以一个技术规划通常要讲清楚，<strong>现状/目标(结果)/路径这三个基本要素</strong>。但现状有多种维度，目标可能有多个，路径也有多条，这时才体现规划的意义，你需要通过思考，调查最客观的现状，最有价值且可行明确的目标，综合最优的实现路径。<br>    综上，技术规划就是一个描述在<strong>有限资源(时间/人力等)内从当前客观现状通过综合最优的实现路径完成最具价值的目标获得最大收益的战略性思考过程</strong>。</p><p>为什么它是一个思考过程?</p><p>因为规划要跟其他人(团队成员/你的leader/支持团队)去对齐，也作为<strong>事后复盘时的依据</strong>，更是晋升报告的能力证明，跳槽时的工作成果，所以要讲清楚整个思考过程。</p><h3 id="技术规划的思考过程"><a href="#技术规划的思考过程" class="headerlink" title="技术规划的思考过程"></a>技术规划的思考过程</h3><h4 id="Step1-目标制定"><a href="#Step1-目标制定" class="headerlink" title="Step1: 目标制定"></a>Step1: 目标制定</h4><h5 id="目标的几种来源"><a href="#目标的几种来源" class="headerlink" title="目标的几种来源"></a>目标的几种来源</h5><p>1.<strong>现有扩展</strong>，过去一些指标的深度优化，或者已有技术债务的偿还。<br>2.<strong>深度挖掘</strong>，对同一标用其他指标来衡量，寻找新的优化方向。<br>3.<strong>新方向探索</strong>，引入新的业界技术与业界前沿建设思路对齐。<br>4.<strong>趋势判断</strong>，预测未来技术发展趋势，尝试将前沿的学界思想引入来建设当前工作，引领颠覆式的创新</p><h5 id="明确可量化的目标"><a href="#明确可量化的目标" class="headerlink" title="明确可量化的目标"></a>明确可量化的目标</h5><p>我们可以对目标做一个简单的分类，针对不同的类型目标有不同的描述方式<br>1.<strong>优化问题</strong>，要写清楚量化的指标，从X提升到Y，或者从X下降到Y。<br>2.<strong>建设问题</strong>，所建设的系统或工具有什么能力/功能，有怎样的使用规模(场景/用户数/客户数等)。</p><h5 id="描述收益的维度"><a href="#描述收益的维度" class="headerlink" title="描述收益的维度"></a>描述收益的维度</h5><p>收益通常从交易，产品，用户三个视角去看</p><p>1.收入，是否可以直接换算为钱，赚的和省的都算作收益<br>2.效率，生产效率的提高，开发/迭代周期缩短，从难到易，减少人力等。<br>3.体验，接口延迟，开机速度，使用流畅度，CTR，留存等等。</p><h5 id="目标的分配"><a href="#目标的分配" class="headerlink" title="目标的分配"></a>目标的分配</h5><p>1.目标要分给其他人一起来完成，要考虑整体可用的人力成本<br>2.按人才梯度去分配，考虑胜任情况与成长挑战。</p><h4 id="Step2-全景图"><a href="#Step2-全景图" class="headerlink" title="Step2:全景图"></a>Step2:全景图</h4><h5 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h5><p>需要从0到1建设的系统，要以DDD的思想进行架构组件的拆解，如果是一个已有的系统也可以试着从0到1的构建.<br>看看不合理之处在哪，逐步重构成最理想的状态。</p><h5 id="全景架构图"><a href="#全景架构图" class="headerlink" title="全景架构图"></a>全景架构图</h5><p>有了领域驱动设计的拆解后，就要把架构组件放到对应的位置上组成一个整体，建设一个全局概念纵向上要分层，横向上要分模块，来描述整个系统的功能组件，让所有同学都清楚全局架构。</p><h5 id="全景功能树"><a href="#全景功能树" class="headerlink" title="全景功能树"></a>全景功能树</h5><p>如果是建设问题，就以用户视角划分功能树，让所有同学都能明白每个部分谁来负责。</p><h5 id="全景指标树"><a href="#全景指标树" class="headerlink" title="全景指标树"></a>全景指标树</h5><p>如果是优化问题，就按指标的计算公式进行拆解，将指标拆解到对应的负责的owner同学身上。</p><h4 id="Step3-里程碑"><a href="#Step3-里程碑" class="headerlink" title="Step3:里程碑"></a>Step3:里程碑</h4><p>规划全景图阶段，就已经确定了目标的实现策略与方案了，那么接下来就是要确保项目真正的能落地，拿到收益</p><p>里程碑本质上是并行执行项目的一个<strong>检查点</strong>，每个里程碑都是<strong>一个具有明确收益的子目标</strong>，多个子方向在里程碑处完成联调与对齐。本质上从理想目标到最终落地的过程，就是一个信息不确定性逐步收敛的过程，风险在开始时最大，完成时变为0。每个里程碑的完成都是对风险的一次收敛。</p><h5 id="小步快跑"><a href="#小步快跑" class="headerlink" title="小步快跑"></a>小步快跑</h5><p>既然项目的落地是一个不确定性逐步收敛的过程，那么最佳的策略就是接受客观的反馈，只有反馈才能消除不确定性，因为反馈就是实验，实验就是观察，只有观察才能消除不确定性(类比海森堡测不准原理)。</p><p>从Demo开始，逐步通过单元测试丰富功能，逐步阶段获得收益，不断实验反馈，最后应用。</p><h5 id="时间倒排"><a href="#时间倒排" class="headerlink" title="时间倒排"></a>时间倒排</h5><p>从最终项目落地的整体DDL开始，给每个关键里程碑一个DDL，时间要留有几余，旦越临近最终DDL时延期的风险应该越小，只有这样才是一个健康的项目管理过程。<br>按时间线细化具体的工作，从年到季度，从季度到月，从月到周，从周到日，由日到每小时的任务，这不需要你一个人来完成，做规划只要到季度目标即可。</p><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>当想要做的事情太多，但可用的资源过少时我们必须进行取舍，人们在做事的时候往往会目标迷失或者膨胀做了与最终目标无益的事情，要么是忘记了最终目的，要么是给自己加戏，等等原因导致延期。</p><p>目标不能仅按重要性和紧急性来区分，因为人们很难判断二者，常受各种情绪和噪声的干扰，短期内认为某件事更重要，也有可能认为某件事过于紧急，实则完全没有必要，白白浪费资源。<br>最佳的策略还是按照我们的第一原则，<strong>项目的落地过程是一个不确定性逐步收敛的过程来看</strong>。那么我们就可以有两个维度，风险和收益，但这里却和我们直觉性的想法有着区别:<br>1.风险是指如果这件事不做或者失败对最终目标的损失是多少?<br>2.收益则是指如果这件事完成，那么对最终目标的完成度贡献几何?<br>这两个维度某种意义上来说，是更加客观，受噪声影响较小的判断方式。</p><p>收益（ROI) = (收益-风险)/成本</p><h4 id="Step4-风险管理"><a href="#Step4-风险管理" class="headerlink" title="Step4:风险管理"></a>Step4:风险管理</h4><p>一个规划如果不能最终落地拿到成果，它就只能对你有思考上的锻炼而没有对外部产生任何价值。好的规划必须要考虑落地过程中的风险，需要对可预见的风险做PlanB，不确定性本身就意味着风险。事实上落地过程中的风险来自于两个方面，技术的风险与人的风险。</p><p>1.<strong>技术风险</strong>，在方案设计阶段不一定可以确定所有的操作都是可行的，执行中遇到无法解决的客观难题时常见的，这会导致排期失效，任务延期。针对这一问题，通常我们要找到上下游所有的决策人，然后达成共识，是选择延期交付还是要砍掉需求，亦或者某种”糙快猛的解决方案来保证交付上的DDL，并且作为项目的owner,要约定好check时间，依据项目的重要性以及紧急情况，约定单周或者双周组织开一次会对齐进度，暴露风险。<br>2.<strong>管理风险</strong>，项目需要人去完成，人存在诸多不稳定因素例如离职/请假/积极性等因素，另外事件发展也会有很多意外情况，法务合规等不可抗力等等，针对这些情况我们制定方案时，原则上要尽早暴露风险，对高风险项要有充足的planB，为最坏情况提前计划，对于<strong>不可撤回的颠覆性思想</strong>要警惕，充分评估后再执行。<br>本质上，项目的落地过程，就是从一个不确定性的想法逐步收敛到确定性结果的过程，从风险与收益的角度来对任务优先级排序要比使用紧急和重要这两个维度更加清晰，先挑选出对于完成最终目标必要性最强的任务，然后优先选择风险高收益大的任务完成，这样我们对不确定性的收敛进度会大幅度提升，项目的落地速度也会更快的完成，这就是所谓要去做难而正确的事，难就是风险大，正确则是收益高。</p><p>丰富经验的项目管理者会发现，所谓项目管理本质上就是风险的管理，这需要在事上炼</p><h4 id="Step5-OKR"><a href="#Step5-OKR" class="headerlink" title="Step5: OKR"></a>Step5: OKR</h4><p>0是目标，KR是关键结果，OKR就是目标+关键结果。0用来描述本质的目标，KR则是用来描述O达成的必要条件，流于形式的OKR通常就是<strong>0不够本质/明确可行，KR不是0的必要条件，在写作OKR时要尤为注意</strong>。</p><p>OKR是组织目标管理工具也是个人目标管理工具，非常值得应用在工作和生活之中。对于知识型工作者它是一种高效的沟通方式，对于个人成长它则是一种高效的自我管理工具，使用OKR最大的收益是它能够帮助我们细化思考过程，是一种<strong>高效率的任务分解工具</strong>，他能够将<strong>长期战略规划与复杂的行动方案</strong>拆解为每个季度/每个月具体可落地执行的任务，让一个长期目标可逐步落地推进，最终实现。</p><p>推荐这个网站去学习OKR的更多知识，在落地应用中要多去翻阅一下这个网站，其中有很多案例与模版可以帮助正确使用。</p><p>整个OKR的实践过程是，具体的全流程实践请参考-&gt;OKR网站学习。<br>| case的调查与收集 -&gt; 写作OKR -&gt; 对齐OKR -&gt; 周计划与排期 -&gt; 周会复盘 -&gt; OKR复盘会(中期/结尾)</p><p>对于技术规划来说我们要聚焦在写作OKR与对齐OKR上面即可。</p><h5 id="写作OKR"><a href="#写作OKR" class="headerlink" title="写作OKR"></a>写作OKR</h5><p>O+KR = 有挑战(信心指数0.7)可量化的本质目标(多问几个为什么)+ 必要的可衡量的关键结果</p><ul><li>从里程碑中拆解出的目标要有本质性，也就是要多去问几个为什么将受益和成本思考清楚。</li><li>KR不是TODO代办列表，是达成目标的必要条件，应该遵循金字塔原理的MECE去拆解。</li></ul><h5 id="对齐OKR"><a href="#对齐OKR" class="headerlink" title="对齐OKR"></a>对齐OKR</h5><ul><li><strong>要把OKR分配给最适合执行的那个人去做</strong>，技术规划通常不是一个人完成(个人OKR也需要他人配合)，要把O分配到具体的人，只有职责到人，这件事才会有人去做才会有结果。</li><li>约会对齐要讲清楚，<strong>O的收益与成本</strong>，其本质目的是为了哪个终极目标服务，KR要说明其<strong>必要性以及如何量化评估</strong>(怎么算完成，怎么算失败)。</li><li>如果时间允许，还可以讲一下调查的case以及方案的取舍过程，但要记住这不是重点，应该快速结束。</li></ul><h3 id="Plato业务架构规划"><a href="#Plato业务架构规划" class="headerlink" title="Plato业务架构规划"></a>Plato业务架构规划</h3><h4 id="规划目标"><a href="#规划目标" class="headerlink" title="规划目标"></a>规划目标</h4><p>从0到1的的设计并实现一个IM系统，这个IM系统在上亿DAU规模下依旧可以保持，高效/稳定/易于维护的特性。<br>一个IM的基本功能大体可以分为四大模块: 用户管理/好友关系/消息管理/会话管理<br><strong>总体约束</strong>:<br>1.基于领域驱动设计的方法完成整个系统的落地<br>2.用户规模假设DAU达到上亿，消息收发QPS达到200K<br>3.除拉取消息接口外P99 不能超过50ms<br>4.消息拉取接口 P99 100ms以下<br>5.一个季度内完成整体的开发流程</p><h4 id="全景图"><a href="#全景图" class="headerlink" title="全景图"></a>全景图</h4><p>回《领域驱动设计精粹》按照此书介绍的DDD方法,我们实战一下IM的业务架构战略设计!</p><h5 id="用功能树进行业务建模"><a href="#用功能树进行业务建模" class="headerlink" title="用功能树进行业务建模"></a>用功能树进行业务建模</h5><p>业务建模 通用语言+业务流程</p><p>由于IM系统的特殊性，其业务流程和专业术语，只要是微信用户基本都知道;多刷刷微信，基本微信上模块名称就是所谓的领域专家的通用语言，然后在辅助了解一下飞书的功能。基本消费级IM和企业级IM的流程就基本理解了，我们的Plato为追求一定的业务复杂度，从业务流程和功能设计上也主要参考微信以及辅助飞书的一些亮点功能。</p><p>注: app是一个持续迭代的系统，很可能当前的微信和飞书功能发生很大变化，Plato这里只会讲一些基础功能但足够大家理解IM系统的本质，也会具有足够的复杂性，未来无论怎么演进，基础架构大概率不会变化。</p><p><a href="./images/plato/plato.png">plato</a></p><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><a href="./images/plato/plato_jg.png">架构图</a></p><h4 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h4><h5 id="时间倒排-1"><a href="#时间倒排-1" class="headerlink" title="时间倒排"></a>时间倒排</h5><p><a href="./images/plato/plato_timeline.png">架构图</a></p><h5 id="战略优先级"><a href="#战略优先级" class="headerlink" title="战略优先级"></a>战略优先级</h5><p>消息/会话/社交 这是核心域，应该投入最多的人力，将其打造为产品竞争力;</p><p>Feed和User不是 但也找不到合适的标准软件，因此是支撑域,要尽量避免在这两个领域投入更多的人力过度设计。<br>Index/SrqlD/MessageStorage 三个基础服务主要负责核心域实体的存储以及高性能检索，本身还是算做领域服务内Cron Job/Cache/Graph 三个基础服务更多的算做基础中台，是支撑域，应该交给其他团队外包开发需要减少依赖各种开元的基础组件 Mysql，RodcksDB，TIDB，MQ等都是通用子域，有现成的开源实现无需开发，只要做好依赖倒置即可。</p><h5 id="OKR拆解"><a href="#OKR拆解" class="headerlink" title="OKR拆解"></a>OKR拆解</h5><p><strong>01:IM系统架构规划和设计(1-2月完成)</strong><br>KR1:创造详细的服务架构设计图用于参考<br>KR2: 确定关键领域的实体设计，形成设计图<br>KR3:设计数据库存储模型以满足IM系统的数据扩展性和稳定性需求</p><p><strong>02:IM系统的核心模块开发(3-4月完成)</strong><br>KR1: 完成IM系统用户管理、消息管理、好友关系以及会话管理模块的基本功能开发。<br>KR2:实现P99响应时间在50ms以内，消息拉取接口P99在100ms以内。<br>KR3:针对用户规模DAU达到上亿，消息收发QPS达到200K的假设。</p><p><strong>03:IM系统部署和运维(5-6月完成)</strong><br>KR1: 构建和部署基础架构组件，例如MySQL、Redis、MQ等。<br>KR2:实施全链路跑通测试，并修复出现的问题<br>KR3:完成IM系统的DevOps流程和环境的建设。</p><p><a href="https://zhuanlan.zhihu.com/p/67498896">技术三板斧：关于技术规划、管理、架构的思考</a><br><a href="https://zhuanlan.zhihu.com/p/347444887">如何成为一名优秀的技术Leader？</a><br><a href="https://zhuanlan.zhihu.com/p/386512987">深入浅谈技术战略规划一二三（一：方法论）</a><br><a href="https://juejin.cn/post/6844904201160491016">技术管理- 怎样做好技术规划？</a><br><a href="https://zhuanlan.zhihu.com/p/500613051">如何做好技术规划</a><br><a href="https://max.book118.com/html/2018/1010/8127013030001126.shtm">技术创新战略规划</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何做技术规划&quot;&gt;&lt;a href=&quot;#如何做技术规划&quot; class=&quot;headerlink&quot; title=&quot;如何做技术规划?&quot;&gt;&lt;/a&gt;如何做技术规划?&lt;/h2&gt;&lt;p&gt;整理自&lt;a href=&quot;https://www.bilibili.com/video/BV1bG</summary>
      
    
    
    
    
    <category term="技术规划" scheme="https://groupfusion.github.io/tags/%E6%8A%80%E6%9C%AF%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>GIS地图开发关键步骤</title>
    <link href="https://groupfusion.github.io/2023/12/25/tools/gis%E5%9C%B0%E5%9B%BE%E9%A1%B9%E7%9B%AE/"/>
    <id>https://groupfusion.github.io/2023/12/25/tools/gis%E5%9C%B0%E5%9B%BE%E9%A1%B9%E7%9B%AE/</id>
    <published>2023-12-25T09:41:20.000Z</published>
    <updated>2023-12-29T07:55:32.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GIS地图开发关键步骤？"><a href="#GIS地图开发关键步骤？" class="headerlink" title="GIS地图开发关键步骤？"></a>GIS地图开发关键步骤？</h2><p>GIS地图开发的步骤或流程可以分为以下几个关键步骤。</p><h3 id="第一步：需求分析"><a href="#第一步：需求分析" class="headerlink" title="第一步：需求分析"></a>第一步：需求分析</h3><p>在开始GIS地图开发之前，首先需要进行需求分析，确定开发的目标和需求。这包括确定地图的类型、功能和使用场景，以及所需的数据类型和数据源。</p><h3 id="第二步：数据采集与处理"><a href="#第二步：数据采集与处理" class="headerlink" title="第二步：数据采集与处理"></a>第二步：数据采集与处理</h3><p>数据是GIS地图开发的基础，因此需要进行数据采集和处理。数据采集可以通过现场调查、遥感技术、GPS定位等方式来获取地理数据。采集到的数据可能需要进行处理，包括数据清洗、格式转换、数据融合等。</p><span id="more"></span><h3 id="第三步：地图设计与制作"><a href="#第三步：地图设计与制作" class="headerlink" title="第三步：地图设计与制作"></a>第三步：地图设计与制作</h3><p>在数据准备完成后，需要进行地图的设计与制作。地图设计包括确定地图的样式、符号、颜色等视觉效果，以及地图的布局和组织结构。地图的制作可以使用专业的地图制作软件，如ArcGIS、QGIS等，也可以使用Web地图开发框架，如OpenLayers、Leaflet等。</p><h3 id="第四步：地图发布与部署"><a href="#第四步：地图发布与部署" class="headerlink" title="第四步：地图发布与部署"></a>第四步：地图发布与部署</h3><p>完成地图的设计与制作后，需要将地图发布到互联网上，使用户可以通过浏览器访问和使用地图。地图发布可以使用Web地图服务（Web Map Service，WMS）或地图切片（Map Tiles）的方式进行。地图部署可以选择自行搭建服务器，也可以使用云服务提供商的地图服务。</p><h3 id="第五步：地图应用开发"><a href="#第五步：地图应用开发" class="headerlink" title="第五步：地图应用开发"></a>第五步：地图应用开发</h3><p>地图应用开发是GIS地图开发的重要环节，可以根据需求开发各种地图应用。地图应用开发可以使用Web开发技术，如HTML、CSS、JavaScript等，也可以使用桌面开发技术，如Java、C#等。地图应用开发可以实现地图的交互操作、数据查询、空间分析等功能。</p><h3 id="第六步：地图优化与维护"><a href="#第六步：地图优化与维护" class="headerlink" title="第六步：地图优化与维护"></a>第六步：地图优化与维护</h3><p>完成地图应用开发后，需要对地图进行优化和维护。地图优化可以包括提高地图的加载速度、优化地图的性能、优化地图的用户体验等。地图维护包括更新地图数据、修复地图bug、升级地图应用等。</p><p>通过以上步骤或流程，可以实现GIS地图开发。在实际应用中，还可以根据具体需求和情况进行调整和扩展。同时，随着互联网技术的不断发展，GIS地图开发也在不断创新和演进，例如引入人工智能、大数据分析等技术，为地图开发带来更多的可能性和挑战。</p><h2 id="地图开发项目推荐"><a href="#地图开发项目推荐" class="headerlink" title="地图开发项目推荐"></a>地图开发项目推荐</h2><p>以下这六款开源项目带开发者们认识地图开发这个充满无限可能的领域。</p><h2 id="GIS站点"><a href="#GIS站点" class="headerlink" title="GIS站点"></a>GIS站点</h2><p><a href="https://www.osgeo.cn/osgeo-live/index.html">osgeo-live</a></p><h3 id="1、xdh-map"><a href="#1、xdh-map" class="headerlink" title="1、xdh-map"></a>1、xdh-map</h3><p>项目作者：铁匠铺<br>开源许可协议：MIT<br>项目地址：<a href="https://gitee.com/newgateway/xdh-map">https://gitee.com/newgateway/xdh-map</a></p><p>xdh-map 是一款基于 Openlayers 的地图应用 Vue 组件。内置了百度、高德、天地图瓦片，并支持与方正、超图、山海经纬、航天精一等PGIS厂商对接。<br>它包含了文本、图形、html、热力图、轨迹回放等20个组件，支持与 ECharts 结合实现散点、飞行迁徙等基于地理位置的图表，满足项目常见需求。</p><p><img src="/images/gis/xdh-map.png" alt="xdh-map"></p><h3 id="2、AntV-L7"><a href="#2、AntV-L7" class="headerlink" title="2、AntV L7"></a>2、AntV L7</h3><p>项目作者：AntV<br>开源许可协议：MIT<br>项目地址：<a href="https://gitee.com/antv/L7">https://gitee.com/antv/L7</a></p><p>L7 是由蚂蚁金服 AntV 数据可视化团队推出的基于 WebGL 的开源大规模地理空间数据可视分析开发框架。L7 专注数据可视化化表达，通过颜色、大小、纹理，方向，体积等视觉变量设置实现从数据到信息清晰，有效的表达。</p><p>L7 能够满足常见的地图图表，BI 系统的可视化分析、以及 GIS，交通，电力，国土，农业，城市等领域的空间信息管理，分析等应用系统开发需求。<br><img src="/images/gis/AntV7.gif" alt="AntVL7"></p><h3 id="3、地图下载器"><a href="#3、地图下载器" class="headerlink" title="3、地图下载器"></a>3、地图下载器</h3><p>项目作者： Crimson<br>开源许可协议： GPL-2.0<br>项目地址：<a href="https://gitee.com/CrimsonHu/java_map_download">https://gitee.com/CrimsonHu/java_map_download</a></p><p>使用 Java 开发的地图瓦片图下载工具，支持 OpenStreetMap、天地图、谷歌地图、高德地图、腾讯地图、必应地图的XYZ瓦片图下载与合并。<br><img src="/images/gis/Crimson.png" alt="Crimson"></p><h3 id="4、QuickEarth-Free"><a href="#4、QuickEarth-Free" class="headerlink" title="4、QuickEarth-Free"></a>4、QuickEarth-Free</h3><p>项目作者： 清风<br>开源许可协议： LGPL-3.0<br>项目地址：<a href="https://gitee.com/mofangbao/quick-earth-free">https://gitee.com/mofangbao/quick-earth-free</a></p><p>QuickEarth（以下简称QE）是一个二三维一体化的 Web 端矢量和栅格数据渲染引擎，适用于气象、海洋、水文、环境等领域的数据可视化。目前二维版本面向个人免费开放。<br><img src="/images/gis/quick-earth-free.jpg" alt="quickEarth"></p><h3 id="5、react-baidu-map"><a href="#5、react-baidu-map" class="headerlink" title="5、react-baidu-map"></a>5、react-baidu-map</h3><p>项目作者： uiw<br>开源许可协议： MIT<br>项目地址：<a href="https://gitee.com/uiw/react-baidu-map">https://gitee.com/uiw/react-baidu-map</a></p><p>react-baidu-map 是一个基于 React 封装的百度地图组件，帮助你轻松的接入地图到 React 项目中。<br><img src="/images/gis/react-baidu-map.png" alt="react-baidu-map"></p><h3 id="6、vue3-ts-cesium-map-show"><a href="#6、vue3-ts-cesium-map-show" class="headerlink" title="6、vue3-ts-cesium-map-show"></a>6、vue3-ts-cesium-map-show</h3><p>项目作者： 地虎降天龙<br>开源许可协议： MIT<br>项目地址：<a href="https://gitee.com/hawk86104/vue3-ts-cesium-map-show">https://gitee.com/hawk86104/vue3-ts-cesium-map-show</a></p><p>这是一个三维可视化数字城市项目，采用了 Cesium-1.82 开源库，配合后台可以实现可视化编辑保存的能力。<br><img src="/images/gis/vue3-ts-cesium-map.png" alt="vue3-ts-cesium"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;GIS地图开发关键步骤？&quot;&gt;&lt;a href=&quot;#GIS地图开发关键步骤？&quot; class=&quot;headerlink&quot; title=&quot;GIS地图开发关键步骤？&quot;&gt;&lt;/a&gt;GIS地图开发关键步骤？&lt;/h2&gt;&lt;p&gt;GIS地图开发的步骤或流程可以分为以下几个关键步骤。&lt;/p&gt;
&lt;h3 id=&quot;第一步：需求分析&quot;&gt;&lt;a href=&quot;#第一步：需求分析&quot; class=&quot;headerlink&quot; title=&quot;第一步：需求分析&quot;&gt;&lt;/a&gt;第一步：需求分析&lt;/h3&gt;&lt;p&gt;在开始GIS地图开发之前，首先需要进行需求分析，确定开发的目标和需求。这包括确定地图的类型、功能和使用场景，以及所需的数据类型和数据源。&lt;/p&gt;
&lt;h3 id=&quot;第二步：数据采集与处理&quot;&gt;&lt;a href=&quot;#第二步：数据采集与处理&quot; class=&quot;headerlink&quot; title=&quot;第二步：数据采集与处理&quot;&gt;&lt;/a&gt;第二步：数据采集与处理&lt;/h3&gt;&lt;p&gt;数据是GIS地图开发的基础，因此需要进行数据采集和处理。数据采集可以通过现场调查、遥感技术、GPS定位等方式来获取地理数据。采集到的数据可能需要进行处理，包括数据清洗、格式转换、数据融合等。&lt;/p&gt;</summary>
    
    
    
    
    <category term="GIS开发" scheme="https://groupfusion.github.io/tags/GIS%E5%BC%80%E5%8F%91/"/>
    
    <category term="WebGIS" scheme="https://groupfusion.github.io/tags/WebGIS/"/>
    
  </entry>
  
  <entry>
    <title>独立开发者周刊003</title>
    <link href="https://groupfusion.github.io/2023/12/25/tools/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85%E5%91%A8%E5%88%8A003/"/>
    <id>https://groupfusion.github.io/2023/12/25/tools/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85%E5%91%A8%E5%88%8A003/</id>
    <published>2023-12-25T07:41:20.000Z</published>
    <updated>2023-12-25T02:05:56.677Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载至<a href="https://www.shenmezhidedu.com/jinri/haowen/10343.html">什么值得读</a></p><p>这是独立开发者周刊的第2期，周刊每周天更新；发布在什么值得读网站，如果你也想成为一名独立开发者，或者对独立开发感兴趣，欢迎收藏什么值得读网站，每周一准时来阅读！</p><p>周刊分为这样几个部分：</p><p>1.新产品推荐&amp;资源分享</p><p>2.值得一读的文章</p><p>3.播客推荐</p><p>4.独立开发idea</p><p>希望这份周刊可以为国内的独立开发生态添上一把火，让更多的互联网人加入到独立自由的新个体中来；</p><p>他们工作，但他们不上班。他们写代码，做产品，但他们不无聊。他们享受创造，更享受这个世界，并用自己的产品让这个世界变得更好了一点。</p><span id="more"></span><h2 id="1-新产品推荐-amp-资源分享"><a href="#1-新产品推荐-amp-资源分享" class="headerlink" title="1.新产品推荐&amp;资源分享"></a>1.新产品推荐&amp;资源分享</h2><p>1)AIPPT</p><p>使用AI一键生成PPT文件，效果不错。</p><p><a href="https://www.aippt.cn/">https://www.aippt.cn/</a></p><p>独立开发者周刊003-什么值得读-互联网人的书单库！<br>2）Runway</p><p>利用AI生成视频内容文件</p><p><a href="https://runwayml.com/">https://runwayml.com/</a></p><p>独立开发者周刊003-什么值得读-互联网人的书单库！<br>3）Yep</p><p>AI搜索引擎，Yep的特点是将90%的广告收入与内容创作者分享，强调隐私保护，不默认使用cookies，不会将用户数据与第三方共享。</p><p><a href="https://yep.com/">https://yep.com/</a></p><p>独立开发者周刊003-什么值得读-互联网人的书单库！<br>4）Giffox</p><p><a href="https://www.giffox.com/">https://www.giffox.com/</a></p><p>电子书资源聚合搜索引擎</p><p>独立开发者周刊003-什么值得读-互联网人的书单库！<br>5）智能TDK：利用AI一键生成网站TDK内容</p><p><a href="https://ai.chinaz.com/seo/tdk">https://ai.chinaz.com/seo/tdk</a></p><p>独立开发者周刊003-什么值得读-互联网人的书单库！<br>6）跨境电商品牌独立站导航</p><p><a href="https://dtctoolbox.com/">https://dtctoolbox.com/</a></p><p>独立开发者周刊003-什么值得读-互联网人的书单库！<br>7）微软网站分析工具：Clarity</p><p><a href="https://clarity.microsoft.com/">https://clarity.microsoft.com/</a></p><p>独立开发者周刊003-什么值得读-互联网人的书单库！<br>7）简单封面</p><p>用最简单的方式制作封面图片，简单好用的封面图制作工具</p><p><a href="https://www.jiandan.link/">https://www.jiandan.link/</a></p><p>独立开发者周刊003-什么值得读-互联网人的书单库！<br>8）Vavebg</p><p>免费的AI图库，可免费下载或用于商业用途。</p><p><a href="https://vavebg.com/">https://vavebg.com/</a></p><p>9）榜一短剧</p><p>短剧资源平台，提供最新抖音、快手短剧和最全的电视剧短剧；</p><p><a href="https://duanju.one/">https://duanju.one/</a></p><p>10）熊猫速读</p><p>通过视频快速了解一本书</p><p><a href="https://qread.xmsoushu.com/">https://qread.xmsoushu.com/</a></p><p>11）大流量卡推荐</p><p>12)极简日历生成器，可免费打印日历</p><p><a href="https://useminimal.com/">https://useminimal.com/</a></p><p>精美、简约的可打印日历、习惯跟踪器和计划表的集合。有 31 种语言版本。</p><p>独立开发者周刊003-什么值得读-互联网人的书单库！<br>13）出海去</p><p><a href="https://chuhaiqu.club/">https://chuhaiqu.club/</a></p><p>独立开发出海社区，『出海去』是一个赋能独立开发 (Indie Hackers) 的孵化平台，为独立开发者提供产品出海所需的一站式服务。</p><p>独立开发者周刊003-什么值得读-互联网人的书单库！</p><h2 id="2-值得一读的文章"><a href="#2-值得一读的文章" class="headerlink" title="2.值得一读的文章"></a>2.值得一读的文章</h2><p>独立开发变现周刊（第115期）：开发一个健身管理软件，月收入6万美元</p><p>科技爱好者周刊（第 281 期）：新基建的政策选择</p><p>Ahrefs Seo教程</p><p>PMF：为何硅谷大神把它念奉为创业公司“唯一重要的东西”？</p><p>独立开发者中，都有哪些「小而美」的设计</p><p>我独立开发的产品是怎样获得最初的 300 个用户的？</p><h2 id="3-播客推荐"><a href="#3-播客推荐" class="headerlink" title="3.播客推荐"></a>3.播客推荐</h2><p>2023技术播客节</p><h2 id="4-独立开发idea"><a href="#4-独立开发idea" class="headerlink" title="4.独立开发idea"></a>4.独立开发idea</h2><p>1）出海的AI项目，做垂直方向的效率工具，做网页或者插件；推荐一个案例：Monica</p><p>2）利用AI来生成社交媒体回复内容，比如回复别人的评论，利用插件，嵌入到网页，交互非常自然。案例：<a href="https://getbirdie.co/">https://getbirdie.co/</a></p><p>3)一个B2B客户线索发现平台，通过订阅制获取收入。通过信息整理也可以变现，提供有价值的内容，就会有人愿意买单。<a href="https://www.getcyberleads.com/">https://www.getcyberleads.com/</a></p><h2 id="订阅-amp-投稿"><a href="#订阅-amp-投稿" class="headerlink" title="订阅&amp;投稿"></a>订阅&amp;投稿</h2><p>加我微信围观独立开发者朋友圈，每周一准时朋友圈分享周刊；</p><p>投稿也可以加下面这个微信，可以投稿你的新产品或者独立开发相关内容。</p><p>独立开发者周刊003-什么值得读-互联网人的书单库！<br>以上就是今日份内容啦，如果你想支持我们的话，就帮忙把这篇文章分享到更多地方吧！感谢～</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文转载至&lt;a href=&quot;https://www.shenmezhidedu.com/jinri/haowen/10343.html&quot;&gt;什么值得读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是独立开发者周刊的第2期，周刊每周天更新；发布在什么值得读网站，如果你也想成为一名独立开发者，或者对独立开发感兴趣，欢迎收藏什么值得读网站，每周一准时来阅读！&lt;/p&gt;
&lt;p&gt;周刊分为这样几个部分：&lt;/p&gt;
&lt;p&gt;1.新产品推荐&amp;amp;资源分享&lt;/p&gt;
&lt;p&gt;2.值得一读的文章&lt;/p&gt;
&lt;p&gt;3.播客推荐&lt;/p&gt;
&lt;p&gt;4.独立开发idea&lt;/p&gt;
&lt;p&gt;希望这份周刊可以为国内的独立开发生态添上一把火，让更多的互联网人加入到独立自由的新个体中来；&lt;/p&gt;
&lt;p&gt;他们工作，但他们不上班。他们写代码，做产品，但他们不无聊。他们享受创造，更享受这个世界，并用自己的产品让这个世界变得更好了一点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="独立开发者" scheme="https://groupfusion.github.io/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
    <category term="转载" scheme="https://groupfusion.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>微前端架构</title>
    <link href="https://groupfusion.github.io/2023/11/15/system&amp;design/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    <id>https://groupfusion.github.io/2023/11/15/system&amp;design/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/</id>
    <published>2023-11-15T07:41:20.000Z</published>
    <updated>2023-12-25T02:03:37.798Z</updated>
    
    <content type="html"><![CDATA[<p>本文概述了微前端，以及如何将遗留用户界面分解为微前端架构。</p><h2 id="什么是微前端？"><a href="#什么是微前端？" class="headerlink" title="什么是微前端？"></a>什么是微前端？</h2><p>微前端是一种架构方法，它将微服务的概念扩展到 Web 应用程序的前端。在微前端体系结构中，复杂的 Web 应用程序被分解为更小的、可独立部署且可维护的单元，称为微前端。每个微前端负责用户界面的特定部分及其相关功能。</p><p>微前端的主要特征和概念包括：</p><ul><li>独立：微前端是自成一体的，独立开发、测试和部署。这种自主权允许不同的团队以最少的协调处理应用程序的不同部分。</li><li>与技术无关：每个微前端都可以使用不同的前端技术（例如，Angular，React，Vue.js），只要它们可以集成到父应用程序或Shell应用程序中即可。</li><li>隔离：微前端在代码和依赖关系方面都是相互隔离的。这种隔离可确保一个微前端中的更改不会影响其他前端。</li><li>集成：容器或 Shell 应用程序负责集成和编排微前端。它提供了用户界面的整体结构，并处理微前端之间的路由。</li><li>独立部署：微前端可以独立部署，从而实现持续交付和更快的更新。这降低了回归问题的风险，并加快了发布周期。</li><li>松散耦合：微前端通过定义良好的 API 和共享协议（如 HTTP）进行通信，从而允许它们松散耦合。这种关注点的分离简化了开发和维护。</li><li>用户界面组合：容器应用程序通过将微前端组合在一起来组装用户界面。这种组合可以在服务器端（服务器端包含）或客户端（客户端路由）上完成。</li><li>扩展和性能：微型前端支持应用程序特定部分的水平扩展，有助于优化频繁访问区域的性能。</li><li>分散式团队：不同的团队或开发团队可以在单独的微前端上工作。这种去中心化对于大型或分布式组织是有利的。</li></ul><p>微前端架构在大型、复杂的 Web 应用程序中特别有用，在这些应用程序中，整体式方法可能会导致开发瓶颈、复杂性增加以及维护和扩展应用程序的困难。</p><p>通过使用微前端，组织可以在其前端开发过程中实现更大的灵活性、敏捷性和可维护性，从而与软件架构领域微服务的更广泛趋势保持一致。</p><h2 id="微前端框架方案"><a href="#微前端框架方案" class="headerlink" title="微前端框架方案"></a>微前端框架方案</h2><h3 id="路由转发"><a href="#路由转发" class="headerlink" title="路由转发"></a>路由转发</h3><p>路由分发式前端，即通过路由将不同的业务分发到不同的独立前端应用上。通常可以通过HTTP服务器的反向代理来实现，或者通过应用框架自带的路由来解决。当前而言，路由分发式的架构是采用得最多、最容易的“微前端”方案。只是将不同的前端应用拼凑到一起，让它们看起来像一个完整的整体。这种应用缺少了对应用状态的处理，对用户的体验不太友好。</p><h3 id="前端微服务化"><a href="#前端微服务化" class="headerlink" title="前端微服务化"></a>前端微服务化</h3><p>前端微服务化是微服务架构在前端的实施，每个前端应用都是完全独立（技术栈、部署、构建独立）、自主运行的，最后通过模块化的方式组合出完整的前端应用。</p><h3 id="组合式集成：微应用化"><a href="#组合式集成：微应用化" class="headerlink" title="组合式集成：微应用化"></a>组合式集成：微应用化</h3><p>微应用化是指，在开发时应用都是以单一、微小应用的形式存在的，而在运行时，则通过构建系统合并这些应用，并组合成一个新的应用。<br>纯前端改造，体验良好，可无感知切换，子应用相互隔离。<br>需要设计和开发，有父子应用处于同一页面运行，需要解决子应用的样式冲突、变量对象污染，通信机制等技术点</p><h3 id="微件化"><a href="#微件化" class="headerlink" title="微件化"></a>微件化</h3><p>微件化是指每个业务团队编写自己的业务代码，并将编译好的代码部署到指定的服务器上。在运行时，我们只需要加载相应的业务模块即可。</p><h3 id="前端容器：iframe"><a href="#前端容器：iframe" class="headerlink" title="前端容器：iframe"></a>前端容器：iframe</h3><p>iframe 可以创建一个全新的独立的宿主环境，类似于沙箱隔离，这意味着我们的前端应用之间可以相互独立运行，仅需要做好应用之间的管理、通信即可。<br>实现简单，子应用之间自带沙箱，天然隔离，互不影响<br>iframe的样式现实、兼容性等都具有局限性。</p><h3 id="结合Web-Components构建"><a href="#结合Web-Components构建" class="headerlink" title="结合Web Components构建"></a>结合Web Components构建</h3><p>Web Components 是一套不同的技术，允许开发者创建可重用的定制元素（它们的功能封装在代码之外）并且在Web应用中使用它们.<br>Web Components技术，离项目应用还有些距离。<br>每个子应用都拥有独立的script和css，也可独立部署。<br>对历史系统改造成本高，子应用通信较为复杂。</p><p>以上6中方案各有优缺点，根据业务等实际情况进行选择。另外，为确保前端体验，不论使用上述那种方案都要完成对应的基座架构框架的搭建。<br>基座就是用于集成各种业务系统前端的框架，可以包括登录、退出</p><h2 id="微前端的业务划分方式"><a href="#微前端的业务划分方式" class="headerlink" title="微前端的业务划分方式"></a>微前端的业务划分方式</h2><p>常见的几种划分微前端的方式：</p><p>  按照业务拆分<br>  按照权限拆分<br>  按照变更的频率拆分<br>  按照组织结构拆分<br>  跟随后端微服务拆分 </p><p>还要根据业务需求选择以上划分方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文概述了微前端，以及如何将遗留用户界面分解为微前端架构。&lt;/p&gt;
&lt;h2 id=&quot;什么是微前端？&quot;&gt;&lt;a href=&quot;#什么是微前端？&quot; class=&quot;headerlink&quot; title=&quot;什么是微前端？&quot;&gt;&lt;/a&gt;什么是微前端？&lt;/h2&gt;&lt;p&gt;微前端是一种架构方法，它将</summary>
      
    
    
    
    
    <category term="系统架构" scheme="https://groupfusion.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>nacos项目集中配置管理设置说明</title>
    <link href="https://groupfusion.github.io/2023/10/14/dev/nacos%E9%A1%B9%E7%9B%AE%E9%9B%86%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E8%AE%BE%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
    <id>https://groupfusion.github.io/2023/10/14/dev/nacos%E9%A1%B9%E7%9B%AE%E9%9B%86%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E8%AE%BE%E7%BD%AE%E8%AF%B4%E6%98%8E/</id>
    <published>2023-10-14T07:41:20.000Z</published>
    <updated>2023-12-15T12:31:37.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nacos项目集中配置管理设置说明"><a href="#nacos项目集中配置管理设置说明" class="headerlink" title="nacos项目集中配置管理设置说明"></a>nacos项目集中配置管理设置说明</h1><p>在springboot 微服项目开发中，微服数量不断增加，长期的结果就是配置文件过于分散混乱，难以管理等问题。这里我们使用nacos配置中心为例，实现统一管理项目中所有配置信息。下面让我们开始吧！</p><h2 id="配置依赖引入"><a href="#配置依赖引入" class="headerlink" title="配置依赖引入"></a>配置依赖引入</h2><p>在build.gradle中增加下面依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#x27;com.alibaba.boot:nacos-config-spring-boot-starter:0.2.12&#x27;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="增加生产环境配置文件"><a href="#增加生产环境配置文件" class="headerlink" title="增加生产环境配置文件"></a>增加生产环境配置文件</h2><p>在application-prod.properties增加配置中心设置信息，配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">nacos.config.bootstrap.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 生产环境配置中心服务器地址，端口</span></span><br><span class="line"><span class="meta">nacos.config.server-addr</span>=<span class="string">192.168.0.18:8848</span></span><br><span class="line"><span class="meta">nacos.config.username</span>=<span class="string">nacos</span></span><br><span class="line"><span class="meta">nacos.config.password</span>=<span class="string">nacos</span></span><br><span class="line"><span class="comment">#默认为Public命名空间,不需要写，如果加上的话会导致加载不到配置文件</span></span><br><span class="line"><span class="meta">nacos.config.namespace</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment">#指定分组信息</span></span><br><span class="line"><span class="meta">nacos.config.group</span>=<span class="string">ORDER_GROUP</span></span><br><span class="line"><span class="comment"># 配置文件ID data-id</span></span><br><span class="line"><span class="meta">nacos.config.data-ids</span>=<span class="string">db.properties,redis.properties,common.properties,order-xxx.properties</span></span><br><span class="line"><span class="comment"># 配置文件类型</span></span><br><span class="line"><span class="meta">nacos.config.type</span>=<span class="string">properties</span></span><br><span class="line"><span class="comment"># 是否允许动态刷新配置项，这里只是为了演示若能，无强烈要求不要开启</span></span><br><span class="line"><span class="meta">nacos.config.auto-refresh</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#logging.config=classpath:logback-spring.xml</span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">/temp/logs/order_xxx.log</span></span><br></pre></td></tr></table></figure><h2 id="配置文件ID-根据模块要求定义"><a href="#配置文件ID-根据模块要求定义" class="headerlink" title="配置文件ID 根据模块要求定义"></a>配置文件ID 根据模块要求定义</h2><p>1、在application-prod.properties中“nacos.config.data-ids=”指定从nacos config中要加载的配置文件；<br>2、db.properties,redis.properties 全局默认不需要修改。<br>3、common.properties 为项目通用的配置<br>4、order-xxx.properties 为业务模块独有的配置；命名规则为：模块名+子模块名(可选)</p><p>注：nacos配置中心设置时，nacos.config.data-ids要与nacos配置中心的data-id一致。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;nacos项目集中配置管理设置说明&quot;&gt;&lt;a href=&quot;#nacos项目集中配置管理设置说明&quot; class=&quot;headerlink&quot; title=&quot;nacos项目集中配置管理设置说明&quot;&gt;&lt;/a&gt;nacos项目集中配置管理设置说明&lt;/h1&gt;&lt;p&gt;在springboot 微服项目开发中，微服数量不断增加，长期的结果就是配置文件过于分散混乱，难以管理等问题。这里我们使用nacos配置中心为例，实现统一管理项目中所有配置信息。下面让我们开始吧！&lt;/p&gt;
&lt;h2 id=&quot;配置依赖引入&quot;&gt;&lt;a href=&quot;#配置依赖引入&quot; class=&quot;headerlink&quot; title=&quot;配置依赖引入&quot;&gt;&lt;/a&gt;配置依赖引入&lt;/h2&gt;&lt;p&gt;在build.gradle中增加下面依赖&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;implementation &amp;#x27;com.alibaba.boot:nacos-config-spring-boot-starter:0.2.12&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="nacos" scheme="https://groupfusion.github.io/tags/nacos/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式应用</title>
    <link href="https://groupfusion.github.io/2023/10/13/readbook/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8/"/>
    <id>https://groupfusion.github.io/2023/10/13/readbook/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8/</id>
    <published>2023-10-13T07:41:20.000Z</published>
    <updated>2023-12-15T12:45:13.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>本篇文章主要介绍策略模式在SpringBoot框架中如何使用。是一篇策略模式的应用实践的文章，需要对设计模式的理论又一定的了解。</p><h3 id="1-1-策略模式简述"><a href="#1-1-策略模式简述" class="headerlink" title="1.1 策略模式简述"></a>1.1 策略模式简述</h3><p>策略模式包含以下3个核心角色：<br>    -  环境（Context）：定义了使用算法的环境，负责将客户端请求委派给具体的策略对象执行。环境类可以通过依赖注入、简单工厂等方式来获取具体策略对象。<br>    -  抽象策略（Abstract Strategy）：定义了策略对象的公共接口或抽象类，规定了具体策略类必须实现的方法。<br>    -  具体策略（Concrete Strategy）：实现了抽象策略定义的接口或抽象类，包含了具体的算法实现。</p><span id="more"></span><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h2><p>作为程序员，无论是在日常开发、学习中，肯定会学习了解各种的设计模式。在开发中我们如果根据需求选择合适的设计模式，使得我们写出的代码更加优雅，且具被拓展性，可读性，是需要我们时刻思考的。</p><p>收到项目现场转来的一个紧急需求，需要解析一批csv格式的文件入库，每个csv文件都对应一套数据，后续跟能还会增加新的数据。看到之前的代码就是一阵无语…，一坨 “if-else” 堆砌代码。</p><h3 id="2-1构建思路"><a href="#2-1构建思路" class="headerlink" title="2.1构建思路"></a>2.1构建思路</h3><p>根据上面的需求不同类型数据文件采用不同的处理方法，对于有经验的程序员，肯定第一个想到的肯定是策略模式。若对设计模式不是很熟，也可根据需求对照设计模式定义挑选。</p><pre><code>- 定义可识别常量：这里根据不同的文件名标识策略类型，使用文件名调用对应的策略实例。- 定义策略接口：每个文件定义一种解析实现，实现对应的解析逻辑，并提取抽接口，定义为对外统一访问入口。- Context设计：通过Map来存储策略定义数据，调用者调用是通过策略标识来获取对应策略实例。在不使用springboot时，需要将策略标识与对应实例直接在代码中写死，这种方式不利于拓展，每次增加策略后都要修改Map。所以强烈建议使用springboot，通过注解方式实现策略的自动注册。新增策略后springboot启动时会扫描策略并对其进行注册，不需要修改旧代码。</code></pre><h3 id="2-2代码实现"><a href="#2-2代码实现" class="headerlink" title="2.2代码实现"></a>2.2代码实现</h3><p>下面我们首先定义策略接口及策略实例,使用springboot框架时只需要在策略实例上增加Component注解，即可将实例注入到Map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CSVParser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String cvsSplitBy = <span class="string">&quot;\\|&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> br</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileType</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parseCsv</span><span class="params">(BufferedReader br, String fileType)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略实现 city_xxxxxx.csv文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;City&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityParser</span> <span class="keyword">implements</span> <span class="title">CSVParser</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ParseResult <span class="title">parseCsv</span><span class="params">(BufferedReader br, String fileType)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;City&quot;</span>);</span><br><span class="line">        <span class="comment">//这里实现csv格式解析以及后续处理，此处省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略实现 region_xxxxxx.csv文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;Region&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegionParser</span> <span class="keyword">implements</span> <span class="title">CSVParser</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseCsv</span><span class="params">(BufferedReader br, String fileType)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Region&quot;</span>);</span><br><span class="line">        <span class="comment">//这里实现csv格式解析以及后续处理，此处省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，编写策略选择器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析策略选择器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseStrategyContext</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里springboot会扫描已定义的策略，并注册到selectParser中</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,CSVParser&gt; selectParser=<span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据资源类型选择对应的解析策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 资源类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CSVParser <span class="title">select</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selectParser.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3拓展"><a href="#2-3拓展" class="headerlink" title="2.3拓展"></a>2.3拓展</h3><p>当需求发生变化，需要增加新类型文件时，只需要新增一个策略实例即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略实现 room_xxxxxx.csv文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;Room&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoomParser</span> <span class="keyword">implements</span> <span class="title">CSVParser</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseCsv</span><span class="params">(BufferedReader br, String fileType)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Room&quot;</span>);</span><br><span class="line">        <span class="comment">//这里实现csv格式解析以及后续处理，此处省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4调用"><a href="#2-4调用" class="headerlink" title="2.4调用"></a>2.4调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewCsvParseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String filePath = <span class="string">&quot;d://temp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    ParseStrategySelector strategySelector;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parseCsv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        File[] childFiles = file.listFiles();</span><br><span class="line">        BufferedReader br;</span><br><span class="line">        <span class="keyword">for</span> (File childFile : childFiles) &#123;</span><br><span class="line">List&lt;String&gt; fileNameList = Arrays.asList(childFile.getName().split(<span class="string">&quot;_&quot;</span>));</span><br><span class="line">String fileType=fileNameList.get(<span class="number">0</span>);</span><br><span class="line">br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(filePath), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"><span class="comment">//根据文件类型，调用不同的策略实例</span></span><br><span class="line">CSVParser parser = strategySelector.select(fileType);</span><br><span class="line">        ParseResult parseResult = parser.parseCsv(br, fileType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>通过使用策略模式模式，大大减少了代码中的 if-else 使用，代码更加优雅，便于扩展。其次，springboot框架能够更加高效的完成开发任务。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h2&gt;&lt;p&gt;本篇文章主要介绍策略模式在SpringBoot框架中如何使用。是一篇策略模式的应用实践的文章，需要对设计模式的理论又一定的了解。&lt;/p&gt;
&lt;h3 id=&quot;1-1-策略模式简述&quot;&gt;&lt;a href=&quot;#1-1-策略模式简述&quot; class=&quot;headerlink&quot; title=&quot;1.1 策略模式简述&quot;&gt;&lt;/a&gt;1.1 策略模式简述&lt;/h3&gt;&lt;p&gt;策略模式包含以下3个核心角色：&lt;br&gt;    -  环境（Context）：定义了使用算法的环境，负责将客户端请求委派给具体的策略对象执行。环境类可以通过依赖注入、简单工厂等方式来获取具体策略对象。&lt;br&gt;    -  抽象策略（Abstract Strategy）：定义了策略对象的公共接口或抽象类，规定了具体策略类必须实现的方法。&lt;br&gt;    -  具体策略（Concrete Strategy）：实现了抽象策略定义的接口或抽象类，包含了具体的算法实现。&lt;/p&gt;</summary>
    
    
    
    
    <category term="设计模式" scheme="https://groupfusion.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合stream流操作示例详解</title>
    <link href="https://groupfusion.github.io/2023/09/15/devlang/java/Java%20%E9%9B%86%E5%90%88stream%E6%B5%81%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://groupfusion.github.io/2023/09/15/devlang/java/Java%20%E9%9B%86%E5%90%88stream%E6%B5%81%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-09-15T07:41:20.000Z</published>
    <updated>2023-12-15T12:41:17.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-集合stream流操作示例详解"><a href="#Java-集合stream流操作示例详解" class="headerlink" title="Java 集合stream流操作示例详解"></a>Java 集合stream流操作示例详解</h1><p>自java 8 版本起推出集合stream流操作特性，确实非常方便的对list进行各种操作，告别使用for的时代来了。下面总结了一些常用的对List对象进行遍历、过滤、查询、去重、排序、分组、提取等操作示例，；</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String sex;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String department;</span><br><span class="line"><span class="keyword">private</span> BigDecimal salary;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id,String name,String sex,Integer age,String department,BigDecimal salary)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"><span class="keyword">this</span>.sex=sex;</span><br><span class="line"><span class="keyword">this</span>.age=age;</span><br><span class="line"><span class="keyword">this</span>.department=department;</span><br><span class="line"><span class="keyword">this</span>.salary=salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListStream</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">List&lt;User&gt; userList = getUserList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;黄文隆&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">32</span>, <span class="string">&quot;研发部&quot;</span>, BigDecimal.valueOf(<span class="number">3600</span>)));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">&quot;江奕云&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">30</span>, <span class="string">&quot;财务部&quot;</span>, BigDecimal.valueOf(<span class="number">3800</span>)));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">&quot;刘姿婷&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="number">20</span>, <span class="string">&quot;人事部&quot;</span>, BigDecimal.valueOf(<span class="number">3700</span>)));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">&quot;夏志豪&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">38</span>, <span class="string">&quot;研发部&quot;</span>, BigDecimal.valueOf(<span class="number">3500</span>)));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="number">5</span>, <span class="string">&quot;林雅南&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="number">25</span>, <span class="string">&quot;财务部&quot;</span>, BigDecimal.valueOf(<span class="number">3200</span>)));</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有一个List<User>类型的列表，可以使用Java8的stream流对它进行遍历、过滤、查询、去重、排序、分组等操作。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userList.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>通过filter()进行数据筛选过滤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取部门为“研发部”的用户列表</span></span><br><span class="line">userList = userList.stream().filter(user -&gt; user.getDepartment() == <span class="string">&quot;研发部&quot;</span>).collect(Collectors.toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取组织编号为“黄文隆”的组织信息，如果没有找到则返回null</span></span><br><span class="line">User user = userList.stream().filter(u -&gt; u.getName().equals(<span class="string">&quot;黄文隆&quot;</span>)).findAny().orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>使用 distinct() 方法可以去除重复的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取部门列表，并去除重复数据</span></span><br><span class="line">    List&lt;String&gt; departmentList = userList.stream().map(User::getDepartment).distinct().collect(Collectors.toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>使用sorted()方法进行数据排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据年龄排序（升序）</span></span><br><span class="line">userList = userList.stream().sorted((u1, u2) -&gt; u1.getAge() - u2.getAge()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//推荐：userList = userList.stream().sorted(Comparator.comparingInt(User::getAge)).collect(Collectors.toList());</span></span><br><span class="line"><span class="comment">//降序：userList = userList.stream().sorted(Comparator.comparingInt(User::getAge).reversed()).collect(Collectors.toList());</span></span><br></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>使用 groupingBy() 将数据进行分组，最终返回一个 Map 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据部门对用户列表进行分组</span></span><br><span class="line">Map&lt;String,List&lt;User&gt;&gt; userMap = userList.stream().collect(Collectors.groupingBy(User::getDepartment));</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据部门和性别对用户列表进行分组</span></span><br><span class="line">Map&lt;String,Map&lt;String,List&lt;User&gt;&gt;&gt; userMap = userList.stream().collect(Collectors.groupingBy(User::getDepartment,Collectors.groupingBy(User::getSex)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据部门进行分组，汇总各个部门用户的平均年龄</span></span><br><span class="line">Map&lt;String, Double&gt; userMap = userList.stream().collect(Collectors.groupingBy(User::getDepartment, Collectors.averagingInt(User::getAge)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h2><p>使用 map() 方法获取用户列表中的名称列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取用户名称列表</span></span><br><span class="line">List&lt;String&gt; nameList = userList.stream().map(User::getName).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//或者：List&lt;String&gt; nameList = userList.stream().map(user -&gt; user.getName()).collect(Collectors.toList());</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="判断-查找"><a href="#判断-查找" class="headerlink" title="判断(查找)"></a>判断(查找)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断用户列表中是否存在名称为“黄文隆”的数据</span></span><br><span class="line"><span class="keyword">boolean</span> result1 = userList.stream().anyMatch(user -&gt; user.getName().equals(<span class="string">&quot;name_01&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断用户名称是否都包含“黄”字段</span></span><br><span class="line"><span class="keyword">boolean</span> result2 = userList.stream().allMatch(user -&gt; user.getName().contains(<span class="string">&quot;黄&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断用户名称是否存在不包含“黄”字段</span></span><br><span class="line"><span class="keyword">boolean</span> result3 = userList.stream().noneMatch(user -&gt; user.getName().contains(<span class="string">&quot;黄&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户列表中年龄的最大值、最小值、总和</span></span><br><span class="line"><span class="keyword">int</span> maxVal = userList.stream().map(User::getAge).reduce(Integer::max).get();</span><br><span class="line"><span class="keyword">int</span> minVal = userList.stream().map(User::getAge).reduce(Integer::min).get();</span><br><span class="line"><span class="keyword">int</span> sumVal = userList.stream().map(User::getAge).reduce(<span class="number">0</span>,Integer::sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户列表中年龄的最大值、最小值、总和、平均值</span></span><br><span class="line"><span class="keyword">int</span> maxVal = userList.stream().mapToInt(User::getAge).max().getAsInt();</span><br><span class="line"><span class="keyword">int</span> minVal = userList.stream().mapToInt(User::getAge).min().getAsInt();</span><br><span class="line"><span class="keyword">int</span> sumVal = userList.stream().mapToInt(User::getAge).sum();</span><br><span class="line"><span class="keyword">double</span> aveVal =  userList.stream().mapToInt(User::getAge).average().getAsDouble();</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计研发部的人数，使用 counting()方法进行统计</span></span><br><span class="line">Long departCount = userList.stream().filter(user -&gt; user.getDepartment() == <span class="string">&quot;研发部&quot;</span>).collect(Collectors.counting());</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计30岁以上的人数，使用 count()方法进行统计（推荐）</span></span><br><span class="line">Long ageCount = userList.stream().filter(user -&gt; user.getAge() &gt;= <span class="number">30</span>).count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计薪资大于1500元的人数</span></span><br><span class="line">Long salaryCount = userList.stream().filter(user -&gt; user.getSalary().compareTo(BigDecimal.valueOf(<span class="number">1500</span>)) == <span class="number">1</span>).count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算年龄总和</span></span><br><span class="line"><span class="keyword">int</span> sumAge = userList.stream().collect(Collectors.summingInt(User::getAge));</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算平均年龄</span></span><br><span class="line"><span class="keyword">double</span> aveAge = userList.stream().collect(Collectors.averagingDouble(User::getAge));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取IntSummaryStatistics对象</span></span><br><span class="line">IntSummaryStatistics ageStatistics = userList.stream().collect(Collectors.summarizingInt(User::getAge));</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计：最大值、最小值、总和、平均值、总数</span></span><br><span class="line">System.out.println(<span class="string">&quot;最大年龄：&quot;</span> + ageStatistics.getMax());</span><br><span class="line">System.out.println(<span class="string">&quot;最小年龄：&quot;</span> + ageStatistics.getMin());</span><br><span class="line">System.out.println(<span class="string">&quot;年龄总和：&quot;</span> + ageStatistics.getSum());</span><br><span class="line">System.out.println(<span class="string">&quot;平均年龄：&quot;</span> + ageStatistics.getAverage());</span><br><span class="line">System.out.println(<span class="string">&quot;员工总数：&quot;</span> + ageStatistics.getCount());</span><br><span class="line"></span><br><span class="line"><span class="comment">//最高薪资</span></span><br><span class="line">BigDecimal maxSalary = userList.stream().map(User::getSalary).max((x1, x2) -&gt; x1.compareTo(x2)).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//最低薪资</span></span><br><span class="line">BigDecimal minSalary = userList.stream().map(User::getSalary).min((x1, x2) -&gt; x1.compareTo(x2)).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//薪资总和</span></span><br><span class="line">BigDecimal sumSalary = userList.stream().map(User::getSalary).reduce(BigDecimal.ZERO, BigDecimal::add);</span><br><span class="line"></span><br><span class="line"><span class="comment">//平均薪资</span></span><br><span class="line">BigDecimal avgSalary = userList.stream().map(User::getSalary).reduce(BigDecimal.ZERO, BigDecimal::add).divide(BigDecimal.valueOf(userList.size()), <span class="number">2</span>, BigDecimal.ROUND_HALF_UP);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java-集合stream流操作示例详解&quot;&gt;&lt;a href=&quot;#Java-集合stream流操作示例详解&quot; class=&quot;headerlink&quot; title=&quot;Java 集合stream流操作示例详解&quot;&gt;&lt;/a&gt;Java 集合stream流操作示例详解&lt;/h1&gt;&lt;p&gt;自java 8 版本起推出集合stream流操作特性，确实非常方便的对list进行各种操作，告别使用for的时代来了。下面总结了一些常用的对List对象进行遍历、过滤、查询、去重、排序、分组、提取等操作示例，；&lt;/p&gt;</summary>
    
    
    
    
    <category term="java stream" scheme="https://groupfusion.github.io/tags/java-stream/"/>
    
  </entry>
  
  <entry>
    <title>linux swap分区调整</title>
    <link href="https://groupfusion.github.io/2023/09/14/linux/linuxswap/"/>
    <id>https://groupfusion.github.io/2023/09/14/linux/linuxswap/</id>
    <published>2023-09-14T07:41:20.000Z</published>
    <updated>2023-12-15T12:44:58.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-swap分区调整"><a href="#linux-swap分区调整" class="headerlink" title="linux swap分区调整"></a>linux swap分区调整</h1><p>近期安装了一套ubantu系统，因为物理机内存有限，想调整swap分区，顾边学边整理的此篇内容。</p><h2 id="swap分区多大合适"><a href="#swap分区多大合适" class="headerlink" title="swap分区多大合适"></a>swap分区多大合适</h2><p>我们在安装系统的时候已经建立了 swap 分区。swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。<br>那么swap分区到底设置成多大才最优？</p><span id="more"></span><p>以前几乎所有Linux 系统管理的书上都推荐设置交换分区大小为内存的2倍。这些建议到了现在就是也适用，具体情况还是要根据实际情况作出调整。</p><p>首先看下Redhat官方的文档中关于swap分区大小设置的建议：</p><table><thead><tr><th>物理内存</th><th align="center">建议的交换空间大小</th><th align="center">如果开启休眠功能建议的教会空间大小</th></tr></thead><tbody><tr><td>&lt;= 2GB</td><td align="center">内存的2倍</td><td align="center">内存的3倍</td></tr><tr><td>&gt;2GB-8GB</td><td align="center">等于内存大小</td><td align="center">内存的2倍</td></tr><tr><td>&gt;8GB-64GB</td><td align="center">至少4G</td><td align="center">内存的1.5倍</td></tr><tr><td>&gt;64GB</td><td align="center">至少4G</td><td align="center">不建议使用休眠</td></tr></tbody></table><p>实际上，系统中交换分区的大小并不取决于物理内存的量，而是取决于系统中内存的负荷，所以在安装系统时要根据具体的业务来设置SWAP的值。</p><p>一般都需要配置一点swap分区，桌面配置多一点，服务器配置少一点。而对于swap分区的具体使用细节，由一个叫swappiness参数来控制。</p><h2 id="Swappiness"><a href="#Swappiness" class="headerlink" title="Swappiness"></a>Swappiness</h2><p>实际上，并不是等所有的物理内存都消耗完毕之后，才去使用swap的空间，什么时候使用是由swappiness 参数值控制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat procsysvmswappiness</span><br></pre></td></tr></table></figure><p>在ubuntu上默认是60,一般大部分都有应该是这个值，也有一些linux版本作出了优化调整。<br>swappiness=0的时候表示最大限度使用物理内存，然后才是 swap空间，<br>swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面</p><h2 id="swap分区调整步骤"><a href="#swap分区调整步骤" class="headerlink" title="swap分区调整步骤"></a>swap分区调整步骤</h2><p>1、我们使用free -m 查看交换空间的大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubtu:~$ free -m</span><br><span class="line">               total        used        free      shared  buffcache   available</span><br><span class="line">内存：       7904        4423         120         371        3360        2817</span><br><span class="line">交换：       2047          55        1992</span><br></pre></td></tr></table></figure><p>2、使用swapon -s 查看交换空间文件挂载的对应的文件<br>如下swapfile既是挂载的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubtu:~$ swapon -s</span><br><span class="line">FilenameTypeSizeUsedPriority</span><br><span class="line">swapfile                               file209714857144-2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、停掉挂载的交换空间的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff swapfile</span><br></pre></td></tr></table></figure><p>4、删除交换空间文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm swapfile</span><br></pre></td></tr></table></figure><p>5、创建新的挂载文件以及设置大小,可参考上面进行设置，因为我的是8G内存，这里交换空间设置8G。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fallocate -l 8G swapfile</span><br></pre></td></tr></table></figure><p>设置完成，可以使用ls -l swapfile 查看创建的swapfile有没有权限。<br>授权如果不为 -rw——- ，请执行 sudo chmod 600 swapfile 给文件赋权。<br>若漏掉则在挂载时会有提示：mkswap: swapfile: insecure permissions 0644, fix with: chmod 0600 swapfile</p><p>6、将文件挂载到交换空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkswap swapfile</span><br></pre></td></tr></table></figure><p>挂载成功提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正在设置交换空间版本 1，大小 = 8 GiB (8589930496  个字节)</span><br><span class="line">无标签， UUID=08420c82-ecbd-4628-96c5-78270950edf8</span><br></pre></td></tr></table></figure><p>7、启动交换空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo swapon  swapfile</span><br></pre></td></tr></table></figure><p>可以free -m 或sudo swapon –show 查看是否设置成功。</p><p>8、若要长久生效，还要使用sudo vi etcfstab 将默认的swapfile 那行注释掉，在最后面增加下面内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapfileswapswapdefault00</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;linux-swap分区调整&quot;&gt;&lt;a href=&quot;#linux-swap分区调整&quot; class=&quot;headerlink&quot; title=&quot;linux swap分区调整&quot;&gt;&lt;/a&gt;linux swap分区调整&lt;/h1&gt;&lt;p&gt;近期安装了一套ubantu系统，因为物理机内存有限，想调整swap分区，顾边学边整理的此篇内容。&lt;/p&gt;
&lt;h2 id=&quot;swap分区多大合适&quot;&gt;&lt;a href=&quot;#swap分区多大合适&quot; class=&quot;headerlink&quot; title=&quot;swap分区多大合适&quot;&gt;&lt;/a&gt;swap分区多大合适&lt;/h2&gt;&lt;p&gt;我们在安装系统的时候已经建立了 swap 分区。swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。&lt;br&gt;那么swap分区到底设置成多大才最优？&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://groupfusion.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>reids 持久化学习笔记</title>
    <link href="https://groupfusion.github.io/2022/11/14/dev/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://groupfusion.github.io/2022/11/14/dev/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-14T07:41:20.000Z</published>
    <updated>2023-12-15T12:39:38.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reids-持久化学习笔记"><a href="#reids-持久化学习笔记" class="headerlink" title="reids 持久化学习笔记"></a>reids 持久化学习笔记</h1><h2 id="RDB快照-snapshot"><a href="#RDB快照-snapshot" class="headerlink" title="RDB快照 (snapshot)"></a>RDB快照 (snapshot)</h2><p>在默认情况下，Redis将内存数据库快照保存在名字为dump.rdb 的二进制文件中。你可以对 Redis进行设置，让它在“N秒内数据集至少有M个改动”这一条件被满足时，自动保存一次数据集.<br>比如说，以下设置会让 Redis 在满足“60 秒内有至少有1000 个键被改动”这一条件时，自动保存一次数据集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#save 60 1000 /关闭RDB只需要将所有的save保存策略注释掉即可</span><br></pre></td></tr></table></figure><p>还可以手动执行命令生成RDB快照，进入redis客户端执行命令<strong>save</strong>或<strong>bgsave</strong>可以生成dump.rdb文件，每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。</p><span id="more"></span><h3 id="bgsave的写时复制-COW-机制"><a href="#bgsave的写时复制-COW-机制" class="headerlink" title="bgsave的写时复制(COW)机制"></a>bgsave的写时复制(COW)机制</h3><p>Redis 借助操作系统提供的写时复制技术(Copy-0n-Write,COW)，在生成快照的同时，依然可以正常处理写命令。简单来说，bgsave 子讲程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 bgsave 子进程相与不影响。但是，如果主线程要修改块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p><p><strong>save与bqsave对比:</strong></p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>是否阻塞redis其它命令</td><td>是</td><td>否（在生成子进程执行调用fork函数时会有短暂阻塞）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fork子进程，消耗内存</td></tr></tbody></table><p><strong>配置自动生成rdb文件后台使用的是bgsave方式</strong></p><h2 id="AOF-append-only-file"><a href="#AOF-append-only-file" class="headerlink" title="AOF (append-only file)"></a>AOF (append-only file)</h2><p>快照功能并不是非常耐久 (durable): 如果 Redis 因为某些原因而造成故障停机，那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从1.1 版本开始，Redis 增加了一种完全耐久的持久化方式:AOF 持久化，将修改的每一条指令记录进文件appendonly.aof中(先写入os cache，每隔一段时间fsync到磁盘)你可以通过修改配置文件来打开AOF功能:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#appendonly yes</span><br></pre></td></tr></table></figure><p>从现在开始，每当Redis 执行一个改变数据集的命令时(比如 SET)，这个命令就会被加到AOF 文件的末尾这样的话，当Redis 重新启动时，程序就可以通过重新执行AOF文件中的命令来达到重建数据集的目的你可以配置Redis多久才将数据fsync到磁盘一次。<br>有三个选项:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always: 每次有新命令退到 AOF 文件时就执行次 fsync ，非常慢，也非常安全</span><br><span class="line">appendfsync everysec: 每秒 fsync 一次，足够快，并且在故障时只会丢失 1 秒钟的数据.</span><br><span class="line">appendfsync no:从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</span><br></pre></td></tr></table></figure><p>推荐(并且也是默认)的措施为每秒fsync一次，这种fsync 策略可以兼顾速度和安全性.</p><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>AOF文件里可能有太多没用指令，所以AOF会定期根据内存的最新数据生成aof文件.例如，执行了如下几条命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incr readcount</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; incr readcount</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; incr readcount</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>重写后AOF文件里变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">SET</span><br><span class="line">$9</span><br><span class="line">readcount</span><br><span class="line">$l</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>如下两个配置可以控制AOF自动重写频率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># auto-aof-rewrite-min-size 64mb //aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不.</span><br><span class="line"># auto-aof-rewrite-percentage 100 //aof文件自上一次重写后文件大小增长了10%则再次触发重写</span><br></pre></td></tr></table></figure><p>当然AOF还可以手动重写，进入redis客户端执行命令 <strong>bgrewriteaof</strong> 重写AOF.</p><p>注意，<strong>AOF重写redis会fork出一个子进程去做(与bgsave命令类似)，不会对redis正常命令处理有太多影响</strong></p><h3 id="RDB和AOF，我应该用哪一个"><a href="#RDB和AOF，我应该用哪一个" class="headerlink" title="RDB和AOF，我应该用哪一个?"></a>RDB和AOF，我应该用哪一个?</h3><table><thead><tr><th>命令</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>容易丢数据</td><td>根据策略决定</td></tr></tbody></table><p>生产环境可以都启用，redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof一般来说数据更全一点.</p><h2 id="Redis-4-0-混合持久化"><a href="#Redis-4-0-混合持久化" class="headerlink" title="Redis 4.0 混合持久化"></a>Redis 4.0 混合持久化</h2><p>重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能术对RDB来说要慢很多，这样在 Redis实例很大的情况下，启动需要花费很长的时间。Redis 4.0 为了解决这个问题，带来了一个新的久化选项 — 混合持久化。<br>通讨如下配置可以开启混合持久化(必须先开启aof)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><p>如果开启混合持久化，<strong>AOF在重写时</strong>，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写<strong>这一刻之前</strong>的内存做RDB快照处理，并且将RDB、内容和增量的AOF修改内存数据的命令存在一起，都写入新的AOF文件，新的文件一开始不叫 apendonly.aof ，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。</p><p>混合持久化AOF文件结构如下：<br>|appendonly.aof |<br>|:–:|<br>|RDB格式 |<br>|  AOF格式 |</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;reids-持久化学习笔记&quot;&gt;&lt;a href=&quot;#reids-持久化学习笔记&quot; class=&quot;headerlink&quot; title=&quot;reids 持久化学习笔记&quot;&gt;&lt;/a&gt;reids 持久化学习笔记&lt;/h1&gt;&lt;h2 id=&quot;RDB快照-snapshot&quot;&gt;&lt;a href=&quot;#RDB快照-snapshot&quot; class=&quot;headerlink&quot; title=&quot;RDB快照 (snapshot)&quot;&gt;&lt;/a&gt;RDB快照 (snapshot)&lt;/h2&gt;&lt;p&gt;在默认情况下，Redis将内存数据库快照保存在名字为dump.rdb 的二进制文件中。你可以对 Redis进行设置，让它在“N秒内数据集至少有M个改动”这一条件被满足时，自动保存一次数据集.&lt;br&gt;比如说，以下设置会让 Redis 在满足“60 秒内有至少有1000 个键被改动”这一条件时，自动保存一次数据集&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#save 60 1000 /关闭RDB只需要将所有的save保存策略注释掉即可&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;还可以手动执行命令生成RDB快照，进入redis客户端执行命令&lt;strong&gt;save&lt;/strong&gt;或&lt;strong&gt;bgsave&lt;/strong&gt;可以生成dump.rdb文件，每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="https://groupfusion.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>reids 数据类型学习笔记</title>
    <link href="https://groupfusion.github.io/2022/11/14/dev/reids%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://groupfusion.github.io/2022/11/14/dev/reids%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-14T07:41:20.000Z</published>
    <updated>2023-12-15T12:39:46.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reids-数据类型学习笔记"><a href="#reids-数据类型学习笔记" class="headerlink" title="reids 数据类型学习笔记"></a>reids 数据类型学习笔记</h1><h2 id="redis-基本数据类型"><a href="#redis-基本数据类型" class="headerlink" title="redis 基本数据类型"></a>redis 基本数据类型</h2><p><img src="/images/redis/a7c36999e90a41038134360ace7da42a.png#pic_center" alt="在这里插入图片描述"></p><span id="more"></span><h3 id="字符串string类型"><a href="#字符串string类型" class="headerlink" title="字符串string类型"></a>字符串string类型</h3><p><strong>常用指令：</strong> set、mset、setnx、get、mget、del、expire。<br><strong>原子加减：</strong> incr、decr、incrby、decrby、</p><p><strong>使用场景：</strong></p><ul><li>单值缓存</li><li>对象缓存</li><li>分布式锁</li><li>计数器</li><li>分布式系统序列号</li></ul><h3 id="哈希hash类型"><a href="#哈希hash类型" class="headerlink" title="哈希hash类型"></a>哈希hash类型</h3><p><strong>常用指令：</strong>hset、hsetnx、hmset、hget、hmget、hdel、hlen、hgetall、hincrby<br><strong>使用场景：</strong></p><ul><li>对象缓存</li><li>购物车（添加商品、增加数量、商品总数、删除商品、获取购物车商品）</li></ul><h3 id="列表list类型"><a href="#列表list类型" class="headerlink" title="列表list类型"></a>列表list类型</h3><p><strong>常用指令：</strong>lpush、rpush、lpop、rpop、lrange、blpop、brpop。<br><strong>使用场景：</strong></p><ul><li>可实现常用分布式数据结构，stack(栈)、Queue（队列）、Blocking MQ（阻塞队列）</li><li>微博、微信消息流，时间线功能。</li></ul><p>注：读扩散、写扩散，千万、亿万粉丝大V发消息，如何推给粉丝？<br>小V写扩散、对用户进行标签，将消息写到活跃用户收件箱</p><h3 id="集合set类型"><a href="#集合set类型" class="headerlink" title="集合set类型"></a>集合set类型</h3><p><strong>常用指令：</strong> sadd、srem、smembers、scard、sismember、srandmember、spop<br><strong>运算操作：</strong> sinter、sinterstore、sunion、sunionstore、sdiff、sdiffstore<br><strong>使用场景：</strong></p><ul><li>抽奖、点赞、收藏、标签</li><li>集合交集、并集、差集</li></ul><h3 id="有序集合ZSet类型"><a href="#有序集合ZSet类型" class="headerlink" title="有序集合ZSet类型"></a>有序集合ZSet类型</h3><p><strong>常用指令：</strong> zadd zrem zscore zincrby zcard、zrange zrevrange、<br><strong>运算操作：</strong>zunionstore、zinterstore<br><strong>使用场景：</strong></p><h2 id="redis底层数据结构"><a href="#redis底层数据结构" class="headerlink" title="redis底层数据结构"></a>redis底层数据结构</h2><ul><li>数组: 根据序号随机查找很快，但是插入与删除很慢，需要挪动很多元素链表:插入与删除很快，只需要修改相邻元素指针，但是查找很慢，需要从第一个元素逐个遍历查找</li></ul><p>有序数组支持折半查找，链表不支持折半查找<br>有序数组的折半查找操作速度很快，但是插入、删除操作很慢</p><ul><li>跳表: 将有序链表改造为支持“折半查找”算法，可以进行快速的插入、删除、查找操作</li></ul><p>跳表与压缩列表优缺点，如何选择。</p><h2 id="Redis经典问题"><a href="#Redis经典问题" class="headerlink" title="Redis经典问题"></a>Redis经典问题</h2><h2 id="3-3-缓存穿透（缓存，数据库都没有数据）"><a href="#3-3-缓存穿透（缓存，数据库都没有数据）" class="headerlink" title="3.3 缓存穿透（缓存，数据库都没有数据）"></a>3.3 缓存穿透（缓存，数据库都没有数据）</h2><p>描述：是指查询一个根本不存在的数据(key)，缓存层和存储层都不会命中。通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层.<br>导致这个请求每次都会请求到数据库，失去了缓存保护后端存储的意义造成缓存穿透的基本原因有两个:<br>第一，自身业务代码或者数据出现问题<br>第二，一些恶意攻击、爬虫等造成大量空命中。<br>3、 突发性热点缓存，<br>解决方案：<br>1、将空数据也设置为缓存，并设置过期时间（几分钟）。<br>2、布隆过滤器。</p><h2 id="3-4-缓存雪崩"><a href="#3-4-缓存雪崩" class="headerlink" title="3.4 缓存雪崩"></a>3.4 缓存雪崩</h2><p>描述：缓存失效（缓存层宕机）后，导致大量请求都会打到存储层，存储层的调用量暴增，造成存储层也会级联宕机的情况。</p><p>解决方案：<br>1、保证缓存层服务的高可用性。<br>2、以来隔离组件为后端限流熔断降级，核心业务访问达数据库，非核心业务返回预定义的信息。<br>3、提前演练。在项目上线前，演练缓存层宕机后，应用及后端的负载情况以及可能出现的问题，在此基础上指定一些预案。</p><h2 id="3-5-缓存击穿"><a href="#3-5-缓存击穿" class="headerlink" title="3.5 缓存击穿"></a>3.5 缓存击穿</h2><p>描述：缓存击穿是指当大量缓存在同一时间失效可能导致大量请求，同时穿透缓存直接访问到数据库。造成数据库压力瞬间骤增，大量请求阻塞，甚至挂掉。</p><p>解决方案：<br>1、针对这些缓存设置不同的过期时间（差异化设置过期时间），如：在24小时基础上增加一个随机数（增加几分钟）。<br>2、使用分布式锁，保证同一时刻只能有一个查询请求重新加载热点数据到缓存中，这样，其他的线程只需等待该线程运行完毕，即可重新从Redis中获取数据。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;reids-数据类型学习笔记&quot;&gt;&lt;a href=&quot;#reids-数据类型学习笔记&quot; class=&quot;headerlink&quot; title=&quot;reids 数据类型学习笔记&quot;&gt;&lt;/a&gt;reids 数据类型学习笔记&lt;/h1&gt;&lt;h2 id=&quot;redis-基本数据类型&quot;&gt;&lt;a href=&quot;#redis-基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;redis 基本数据类型&quot;&gt;&lt;/a&gt;redis 基本数据类型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/redis/a7c36999e90a41038134360ace7da42a.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="https://groupfusion.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java对象进入老年代的条件</title>
    <link href="https://groupfusion.github.io/2022/09/15/dev/Java%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E6%9D%A1%E4%BB%B6/"/>
    <id>https://groupfusion.github.io/2022/09/15/dev/Java%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E6%9D%A1%E4%BB%B6/</id>
    <published>2022-09-15T07:41:20.000Z</published>
    <updated>2023-12-15T12:39:02.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java对象进入老年代的条件"><a href="#Java对象进入老年代的条件" class="headerlink" title="Java对象进入老年代的条件"></a>Java对象进入老年代的条件</h1><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>大对象就是需要大量连续内存空间的对象。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。</p><p>比如设置JVM参数：-XX:PretenureSizeThreshold=1000000 (单位是字节) -XX:+UseSerialGC ，再执行下上面的第一个程序会发现大对象直接进了老年代。</p><span id="more"></span><h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p><h2 id="对象动态年龄判断"><a href="#对象动态年龄判断" class="headerlink" title="对象动态年龄判断"></a>对象动态年龄判断</h2><p>当前放对象的Survivor区域里（其中一块区域，放对象的那块s区），一批对象的总大小大于这块Survivor区域内存大小的50%（-XX:TargetSurvivorRatio可以指定），那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了，例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年龄判断机制一般是在minor gc之后触发的。</p><h2 id="老年代空间分配担保机制"><a href="#老年代空间分配担保机制" class="headerlink" title="老年代空间分配担保机制"></a>老年代空间分配担保机制</h2><p>年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间。如果这个可用空间小于年轻代里现有的所有对象大小之和。</p><p>就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了。如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放新的对象就会发生”OOM”。</p><p>当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java对象进入老年代的条件&quot;&gt;&lt;a href=&quot;#Java对象进入老年代的条件&quot; class=&quot;headerlink&quot; title=&quot;Java对象进入老年代的条件&quot;&gt;&lt;/a&gt;Java对象进入老年代的条件&lt;/h1&gt;&lt;h2 id=&quot;大对象直接进入老年代&quot;&gt;&lt;a href=&quot;#大对象直接进入老年代&quot; class=&quot;headerlink&quot; title=&quot;大对象直接进入老年代&quot;&gt;&lt;/a&gt;大对象直接进入老年代&lt;/h2&gt;&lt;p&gt;大对象就是需要大量连续内存空间的对象。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。&lt;/p&gt;
&lt;p&gt;比如设置JVM参数：-XX:PretenureSizeThreshold=1000000 (单位是字节) -XX:+UseSerialGC ，再执行下上面的第一个程序会发现大对象直接进了老年代。&lt;/p&gt;</summary>
    
    
    
    
    <category term="jvm" scheme="https://groupfusion.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm垃圾回收机制理解</title>
    <link href="https://groupfusion.github.io/2022/08/15/dev/jvm%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3/"/>
    <id>https://groupfusion.github.io/2022/08/15/dev/jvm%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3/</id>
    <published>2022-08-15T07:41:20.000Z</published>
    <updated>2023-12-15T12:39:16.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm-垃圾回收机制理解"><a href="#jvm-垃圾回收机制理解" class="headerlink" title="jvm 垃圾回收机制理解"></a>jvm 垃圾回收机制理解</h1><h2 id="堆内存区域划分"><a href="#堆内存区域划分" class="headerlink" title="堆内存区域划分"></a>堆内存区域划分</h2><p>堆内存被划分为年轻代和老年代两个区域，而年轻代又分为一个伊甸园区（Eden）和两个幸存区（from_Survivor和to_Survivor），年轻代分配比例8：1：1。</p><p>##了解垃圾回收机制前我们要先了解下，如何判断对象可用被回收？</p><p>将“GC roots”对象作为根节点，从根节点开始向下查找引用对象，直到最后一个节点，找到的对象都标记为<strong>非垃圾对象</strong>，其余未标记的都是垃圾对象。<br>线程栈中的本地变量，静态变量，本地方法中的变量都可用作为GC roots根节点， 这就是可达性分析算法。</p><p>标记为非垃圾的对象会被复制空的survivor区，对象的分代年龄加1，剩余伊甸园区的垃圾对象会被清除。当伊甸园区域再次满了后会再次触发minor gc。<br>再次根据可达性分析算法标记非垃圾对象，重复上面的操作。<br>当长期存活对象（分代年龄达到15）和大对象，将会放到老年区。</p><span id="more"></span><h2 id="对象动态年龄判断"><a href="#对象动态年龄判断" class="headerlink" title="对象动态年龄判断"></a>对象动态年龄判断</h2><p>还有当前放对象的Survivor区域里（其中一块区域，放对象的那块s区），一批对象的总大小大于这块Survivor区域内存大小的50%（-XX:TargetSurvivorRatio可以指定），那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了，例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年龄判断机制一般是在minor gc之后触发的。</p><h2 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h2><p>当老年代满了后，进行一次full gc，老年代依然满着，这时会出OOM内存溢出。<br>我们调优的目的主要就是减少full gc 次数，以减少STW（Stop the World），STW是指full gc时，会暂停当前执行线程，等待full gc结束，即在full gc期间，JVM虚拟机是暂停的。</p><p><strong>注：一般老年代占对内存的2/3.</strong></p><h2 id="频繁full-gc-如何解决？"><a href="#频繁full-gc-如何解决？" class="headerlink" title="频繁full gc 如何解决？"></a><strong>频繁full gc 如何解决？</strong></h2><p>能否对jvm调优，让虚拟机几乎不发生full gc，<br>当系统一次性加载过多数据进内存，导致频繁有大对象进入老年代，触发Full GC。我们可调整伊甸园区（Eden)大小 通过-Xmn 参数调整。具体如何调优还要根据实际情况。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;jvm-垃圾回收机制理解&quot;&gt;&lt;a href=&quot;#jvm-垃圾回收机制理解&quot; class=&quot;headerlink&quot; title=&quot;jvm 垃圾回收机制理解&quot;&gt;&lt;/a&gt;jvm 垃圾回收机制理解&lt;/h1&gt;&lt;h2 id=&quot;堆内存区域划分&quot;&gt;&lt;a href=&quot;#堆内存区域划分&quot; class=&quot;headerlink&quot; title=&quot;堆内存区域划分&quot;&gt;&lt;/a&gt;堆内存区域划分&lt;/h2&gt;&lt;p&gt;堆内存被划分为年轻代和老年代两个区域，而年轻代又分为一个伊甸园区（Eden）和两个幸存区（from_Survivor和to_Survivor），年轻代分配比例8：1：1。&lt;/p&gt;
&lt;p&gt;##了解垃圾回收机制前我们要先了解下，如何判断对象可用被回收？&lt;/p&gt;
&lt;p&gt;将“GC roots”对象作为根节点，从根节点开始向下查找引用对象，直到最后一个节点，找到的对象都标记为&lt;strong&gt;非垃圾对象&lt;/strong&gt;，其余未标记的都是垃圾对象。&lt;br&gt;线程栈中的本地变量，静态变量，本地方法中的变量都可用作为GC roots根节点， 这就是可达性分析算法。&lt;/p&gt;
&lt;p&gt;标记为非垃圾的对象会被复制空的survivor区，对象的分代年龄加1，剩余伊甸园区的垃圾对象会被清除。当伊甸园区域再次满了后会再次触发minor gc。&lt;br&gt;再次根据可达性分析算法标记非垃圾对象，重复上面的操作。&lt;br&gt;当长期存活对象（分代年龄达到15）和大对象，将会放到老年区。&lt;/p&gt;</summary>
    
    
    
    
    <category term="jvm" scheme="https://groupfusion.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>工作学习中技术积累</title>
    <link href="https://groupfusion.github.io/2021/12/26/devlang/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    <id>https://groupfusion.github.io/2021/12/26/devlang/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/</id>
    <published>2021-12-26T08:29:57.000Z</published>
    <updated>2023-12-15T12:42:17.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用技术纪录"><a href="#使用技术纪录" class="headerlink" title="使用技术纪录"></a>使用技术纪录</h2><h3 id="百度指定网站搜索"><a href="#百度指定网站搜索" class="headerlink" title="百度指定网站搜索"></a>百度指定网站搜索</h3><p>site:(jianshu.com) WKT</p><h3 id="在线工具站点"><a href="#在线工具站点" class="headerlink" title="在线工具站点"></a>在线工具站点</h3><p><a href="https://tooltt.com/yaml2properties/">yaml转properties</a><br><a href="https://www.box3.cn/tools/lbs.html">经纬度距离计算</a></p><span id="more"></span><h3 id="mysql-install"><a href="#mysql-install" class="headerlink" title="mysql install"></a>mysql install</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql57-community-release-el6-10.noarch.rpm</span><br><span class="line">报错</span><br><span class="line">No package matched to upgrade: mysql57-community-release</span><br><span class="line">--&gt; Finished Dependency Resolution</span><br><span class="line">Error: mysql57-community-release conflicts with mysql-community-release-el6-5.noarch</span><br><span class="line">You could try using --skip-broken to work around the problem</span><br><span class="line">You could try running: rpm -Va --nofiles --nodigest</span><br><span class="line"></span><br><span class="line">rpm -qa |grep mysql 查看有如下内容</span><br><span class="line">mysql-community-release-el6-5.noarch</span><br><span class="line">mysql-community-common-5.6.44-2.el6.x86_64</span><br><span class="line"></span><br><span class="line">操作一下 卸载了</span><br><span class="line">rpm -e --nodeps mysql-community-release-el6-5.noarch</span><br><span class="line">rpm -e --nodeps mysql-community-common-5.6.44-2.el6.x86_64</span><br><span class="line"></span><br><span class="line">重新升级</span><br><span class="line"></span><br><span class="line">rpm -Uvh mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></table></figure><h4 id="centos6-mysql5-6-升级"><a href="#centos6-mysql5-6-升级" class="headerlink" title="centos6 mysql5.6 升级"></a>centos6 mysql5.6 升级</h4><p><a href="http://www.zsythink.net/archives/2345">http://www.zsythink.net/archives/2345</a><br><a href="https://blog.csdn.net/h330531987/article/details/94452368">https://blog.csdn.net/h330531987/article/details/94452368</a><br><a href="https://www.cnblogs.com/daixh/p/11129768.html">https://www.cnblogs.com/daixh/p/11129768.html</a><br><a href="https://www.cnblogs.com/shione/p/10161021.html">https://www.cnblogs.com/shione/p/10161021.html</a></p><h3 id="CSS书写规范、顺序"><a href="#CSS书写规范、顺序" class="headerlink" title="CSS书写规范、顺序"></a>CSS书写规范、顺序</h3><p><a href=".css%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83%E9%A1%BA%E5%BA%8F.md">css书写规范顺序</a></p><h3 id="flowable-工作流与springboot集成"><a href="#flowable-工作流与springboot集成" class="headerlink" title="flowable 工作流与springboot集成"></a>flowable 工作流与springboot集成</h3><p><a href="https://www.cnblogs.com/yangjiming/p/10944120.html">springboot和flowable modeler整合</a><br><a href="https://www.jianshu.com/p/d9ae64fac55c">Springboot集成flowable modeler 免登录</a><br><a href="https://www.jianshu.com/p/799b1ebf5dc4?tdsourcetag=s_pctim_aiomsg">Flowable 学习笔记</a><br><a href="https://blog.csdn.net/puhaiyang/article/details/79845248">采用springboot+flowable快速实现工作流</a><br><a href="https://blog.csdn.net/weixin_40816738/article/details/103112704">SpringBoot集成flowable-modeler(6.4.1) 实现免登</a><br><a href="https://tkjohn.github.io/flowable-userguide/#_advanced">Flowable BPMN 用户手册 (v 6.3.0)</a><br><a href="https://www.dazhuanlan.com/2020/01/06/5e128b27059e9/">SpringBoot集成Flowable UI</a><br><a href="http://www.fhadmin.org/webnewsdetail16.html">Flowable 工作流 Springboot vue.js 前后分离 跨域 有代码生成器</a></p><p><a href="https://gitee.com/blackzs/flowable-designer">flowable-designer</a></p><h3 id="openlayers-gis开发"><a href="#openlayers-gis开发" class="headerlink" title="openlayers gis开发"></a>openlayers gis开发</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">var mapUrl = &#123;</span><br><span class="line">    /****</span><br><span class="line">     * 高德地图</span><br><span class="line">     * lang可以通过zh_cn设置中文，en设置英文，size基本无作用，scl设置标注还是底图，scl=1代表注记，</span><br><span class="line">     * scl=2代表底图（矢量或者影像），style设置影像和路网，style=6为影像图，</span><br><span class="line">     * vec——街道底图</span><br><span class="line">     * img——影像底图</span><br><span class="line">     * roadLabel---路网+标注</span><br><span class="line">     */</span><br><span class="line">    &quot;aMap-img&quot;: &quot;http://webst0&#123;1-4&#125;.is.autonavi.com/appmaptile?style=6&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&quot;,</span><br><span class="line">    &quot;aMap-vec&quot;: &quot;http://webrd0&#123;1-4&#125;.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=8&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&quot;,</span><br><span class="line">    &quot;aMap-roadLabel&quot;: &quot;http://webst0&#123;1-4&#125;.is.autonavi.com/appmaptile?style=8&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&quot;,</span><br><span class="line">    /***</span><br><span class="line">    *高德新版地图*</span><br><span class="line">    */</span><br><span class="line">    &quot;aMap-vec-a&quot;: &quot;http://wprd0&#123;1-4&#125;.is.autonavi.com/appmaptile?x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;lang=zh_cn&amp;size=1&amp;scl=1&amp;style=7&quot;, //为矢量图（含路网、含注记）</span><br><span class="line"></span><br><span class="line">    &quot;aMap-img-n&quot;: &quot;http://wprd0&#123;1-4&#125;.is.autonavi.com/appmaptile?x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;lang=zh_cn&amp;size=1&amp;scl=1&amp;style=6&quot;, //为影像底图（不含路网，不含注记）</span><br><span class="line"></span><br><span class="line">    &quot;aMap-img-a&quot;: &quot;http://wprd0&#123;1-4&#125;.is.autonavi.com/appmaptile?x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&amp;lang=zh_cn&amp;size=1&amp;scl=1&amp;style=8&quot;, //为影像路图（含路网，含注记）</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 天地图 要key的</span><br><span class="line">     * vec——街道底图</span><br><span class="line">     * img——影像底图</span><br><span class="line">     * ter——地形底图</span><br><span class="line">     * cva——中文注记</span><br><span class="line">     * cta/cia——道路+中文注记 ---roadLabel</span><br><span class="line">     */</span><br><span class="line">    &quot;tian-img&quot;: &quot;http://t&#123;0-7&#125;.tianditu.gov.cn/DataServer?T=img_w&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;z&#125;&amp;tk=你的密钥&quot;,</span><br><span class="line">    &quot;tian-roadLabel&quot;: &quot;http://t&#123;0-7&#125;.tianditu.gov.cn/DataServer?T=cta_w&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;z&#125;&amp;tk=你的密钥&quot;,</span><br><span class="line">    &quot;tian-label&quot;: &quot;http://t&#123;0-7&#125;.tianditu.gov.cn/DataServer?T=cva_w&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;z&#125;&amp;tk=你的密钥&quot;,</span><br><span class="line">    &quot;tian-vec&quot;: &quot;http://t&#123;0-7&#125;.tianditu.gov.cn/DataServer?T=vec_w&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;z&#125;&amp;tk=你的密钥&quot;,</span><br><span class="line">    &quot;tian-ter&quot;: &quot;http://t&#123;0-7&#125;.tianditu.gov.cn/DataServer?T=ter_w&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;z&#125;&amp;tk=你的密钥&quot;,</span><br><span class="line">    /***</span><br><span class="line">     *geoq地图</span><br><span class="line">     * http://cache1.arcgisonline.cn</span><br><span class="line">     * http://map.geoq.cn</span><br><span class="line">     * vec：标准彩色地图</span><br><span class="line">     * gray、blue、warm</span><br><span class="line">     * line 中国轮廓图</span><br><span class="line">     * china 中国轮廓图+标注</span><br><span class="line">     * Hydro 水系</span><br><span class="line">     * green 植被</span><br><span class="line">     */</span><br><span class="line">    &quot;geoq-vec&quot;: &quot;http://cache1.arcgisonline.cn/arcgis/rest/services/ChinaOnlineCommunity/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&quot;,</span><br><span class="line">    &quot;geoq-gray&quot;: &quot;http://cache1.arcgisonline.cn/arcgis/rest/services/ChinaOnlineStreetGray/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&quot;,</span><br><span class="line">    &quot;geoq-blue&quot;: &quot;http://cache1.arcgisonline.cn/arcgis/rest/services/ChinaOnlineStreetPurplishBlue/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&quot;,</span><br><span class="line">    &quot;geoq-warm&quot;: &quot;http://cache1.arcgisonline.cn/arcgis/rest/services/ChinaOnlineStreetWarm/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&quot;,</span><br><span class="line">    &quot;geoq-line&quot;: &quot;http://cache1.arcgisonline.cn/arcgis/rest/services/SimpleFeature/ChinaBoundaryLine/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&quot;,//不稳定</span><br><span class="line">    &quot;geoq-china&quot;: &quot;http://thematic.geoq.cn/arcgis/rest/services/ThematicMaps/administrative_division_boundaryandlabel/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&quot;,//不稳定</span><br><span class="line">    &quot;geoq-Hydro&quot;: &quot;http://thematic.geoq.cn/arcgis/rest/services/ThematicMaps/WorldHydroMap/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&quot;,//不稳定</span><br><span class="line">    &quot;geoq-green&quot;: &quot;http://thematic.geoq.cn/arcgis/rest/services/ThematicMaps/vegetation/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&quot;,//不稳定</span><br><span class="line">    /***</span><br><span class="line">     * Google</span><br><span class="line">     * m 街道</span><br><span class="line">     * s 影像</span><br><span class="line">     */</span><br><span class="line">    &quot;google-vec&quot;: &quot;http://www.google.cn/maps/vt?lyrs=m@189&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&quot;,</span><br><span class="line">    &quot;google-img&quot;: &quot;http://www.google.cn/maps/vt?lyrs=s@189&amp;gl=cn&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="GIS底图－－-天地图"><a href="#GIS底图－－-天地图" class="headerlink" title="GIS底图－－ 天地图"></a>GIS底图－－ 天地图</h4><p>// //<a href="http://www.arcgisonline.cn/arcgis/home/webmap/viewer.html">http://www.arcgisonline.cn/arcgis/home/webmap/viewer.html</a> 地图可参考这个链接<br>// 影像地图（球面墨卡托投影）<br>// 天地图-影像注记（球面墨卡托投影）<br>// <a href="https://t{0-7}.tianditu.gov.cn/cia_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=cia&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX=%7Bz%7D&amp;TILEROW=%7By%7D&amp;TILECOL=%7Bx%7D&amp;tk=4267820f43926eaf808d61dc07269beb">https://t{0-7}.tianditu.gov.cn/cia_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=cia&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX={z}&amp;TILEROW={y}&amp;TILECOL={x}&amp;tk=4267820f43926eaf808d61dc07269beb</a><br>// 天地图-影像地图（球面墨卡托投影）<br>// <a href="https://t{0-7}.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=img&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX=%7Bz%7D&amp;TILEROW=%7By%7D&amp;TILECOL=%7Bx%7D&amp;tk=4267820f43926eaf808d61dc07269beb">https://t{0-7}.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=img&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX={z}&amp;TILEROW={y}&amp;TILECOL={x}&amp;tk=4267820f43926eaf808d61dc07269beb</a><br>//<br>// 矢量地图（球面墨卡托投影）<br>// 天地图-矢量注记（球面墨卡托投影）<br>// <a href="https://t{0-7}.tianditu.gov.cn/cva_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=cva&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX=%7Bz%7D&amp;TILEROW=%7By%7D&amp;TILECOL=%7Bx%7D&amp;tk=4267820f43926eaf808d61dc07269beb">https://t{0-7}.tianditu.gov.cn/cva_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=cva&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX={z}&amp;TILEROW={y}&amp;TILECOL={x}&amp;tk=4267820f43926eaf808d61dc07269beb</a><br>// 天地图-矢量地图（球面墨卡托投影）<br>// <a href="https://t{0-7}.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=vec&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX=%7Bz%7D&amp;TILEROW=%7By%7D&amp;TILECOL=%7Bx%7D&amp;tk=4267820f43926eaf808d61dc07269beb">https://t{0-7}.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=vec&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX={z}&amp;TILEROW={y}&amp;TILECOL={x}&amp;tk=4267820f43926eaf808d61dc07269beb</a><br>//<br>// 天地图-矢量（含注记）（球面墨卡托投影）<br>// 天地图-矢量地图（球面墨卡托投影）<br>// <a href="http://t{0-7}.tianditu.com/vec_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=vec&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX=12&amp;TILEROW=1550&amp;TILECOL=3372&amp;tk=4267820f43926eaf808d61dc07269beb">http://t{0-7}.tianditu.com/vec_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=vec&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX=12&amp;TILEROW=1550&amp;TILECOL=3372&amp;tk=4267820f43926eaf808d61dc07269beb</a><br>// 天地图-矢量注记（球面墨卡托投影）<br>// <a href="http://t{0-7}.tianditu.com/cva_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=cva&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX=12&amp;TILEROW=1551&amp;TILECOL=3372&amp;tk=4267820f43926eaf808d61dc07269beb">http://t{0-7}.tianditu.com/cva_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=cva&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX=12&amp;TILEROW=1551&amp;TILECOL=3372&amp;tk=4267820f43926eaf808d61dc07269beb</a><br>// </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//天地图［可用］［无需纠偏］</span><br><span class="line">var tian_di_tuMapLayer = new ol.layer.Tile(&#123;</span><br><span class="line">    title:&#x27;天地图卫星影像&#x27;,</span><br><span class="line">    source: new ol.source.XYZ(&#123;</span><br><span class="line">        url:&#x27;http://t&#123;1-7&#125;.tianditu.com/DataServer?T=img_w&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;z&#125;&amp;tk=49ea1deec0ffd88ef13a3f69987e9a63&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">//天地图路网 (和注记一起使用)［可用］［无需纠偏］</span><br><span class="line">var tian_di_tu_road_layer = new ol.layer.Tile(&#123;</span><br><span class="line">    title: &quot;天地图路网&quot;,</span><br><span class="line">    source: new ol.source.XYZ(&#123;</span><br><span class="line">        url: &quot;http://t&#123;1-7&#125;.tianditu.com/DataServer?T=vec_w&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;z&#125;&amp;tk=49ea1deec0ffd88ef13a3f69987e9a63&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">//天地图注记</span><br><span class="line">var tian_di_tu_annotation = new ol.layer.Tile(&#123;</span><br><span class="line">    title: &quot;天地图文字标注&quot;,</span><br><span class="line">    source: new ol.source.XYZ(&#123;</span><br><span class="line">        url: &#x27;http://t&#123;1-7&#125;.tianditu.com/DataServer?T=cva_w&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;z&#125;&amp;tk=49ea1deec0ffd88ef13a3f69987e9a63&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">//天地图 ［无需纠偏］</span><br><span class="line">var arcgisLayer = new ol.layer.Tile(&#123;</span><br><span class="line">  title:&#x27;天地图卫星影像&#x27;,</span><br><span class="line">  source: new ol.source.XYZ(&#123;</span><br><span class="line">    crossOrigin: &#x27;anonymous&#x27;,</span><br><span class="line">    url:&#x27;https://t&#123;1-7&#125;.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=img&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX=&#123;z&#125;&amp;TILEROW=&#123;y&#125;&amp;TILECOL=&#123;x&#125;&amp;tk=4267820f43926eaf808d61dc07269beb&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">var arcgis2Layer = new ol.layer.Tile(&#123;</span><br><span class="line">  title: &quot;天地图矢量地图&quot;,</span><br><span class="line">  source: new ol.source.XYZ(&#123;</span><br><span class="line">    crossOrigin: &#x27;anonymous&#x27;,</span><br><span class="line">    url:&#x27;https://t&#123;0-7&#125;.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=vec&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX=&#123;z&#125;&amp;TILEROW=&#123;y&#125;&amp;TILECOL=&#123;x&#125;&amp;tk=4267820f43926eaf808d61dc07269beb&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">var arcgis3Layer = new ol.layer.Tile(&#123;</span><br><span class="line">  title:&#x27;天地图-矢量地图&#x27;,</span><br><span class="line">  source: new ol.source.XYZ(&#123;</span><br><span class="line">    crossOrigin: &#x27;anonymous&#x27;,</span><br><span class="line">    url:&#x27;https://t&#123;0-7&#125;.tianditu.gov.cn/cva_w/wmts?SERVICE=WMTS&amp;VERSION=1.0.0&amp;REQUEST=GetTile&amp;LAYER=cva&amp;STYLE=default&amp;FORMAT=tiles&amp;TILEMATRIXSET=w&amp;TILEMATRIX=&#123;z&#125;&amp;TILEROW=&#123;y&#125;&amp;TILECOL=&#123;x&#125;&amp;tk=4267820f43926eaf808d61dc07269beb&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="GIS底图－－-高德地图"><a href="#GIS底图－－-高德地图" class="headerlink" title="GIS底图－－ 高德地图"></a>GIS底图－－ 高德地图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//高德矢量图［可用］ 需要纠偏</span><br><span class="line">var gaodeMapLayer = new ol.layer.Tile(&#123;</span><br><span class="line">    source: new ol.source.XYZ(&#123;</span><br><span class="line">        url:&#x27;https://wprd0&#123;1-4&#125;.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;style=7&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;z=&#123;z&#125;&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="GIS底图－－-捷泰地图"><a href="#GIS底图－－-捷泰地图" class="headerlink" title="GIS底图－－ 捷泰地图"></a>GIS底图－－ 捷泰地图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//arcgis 矢量图［可用］ 需要纠偏</span><br><span class="line">var backLayer = new ol.layer.Tile(&#123;</span><br><span class="line">  source: new ol.source.XYZ(&#123;</span><br><span class="line">    crossOrigin: &#x27;anonymous&#x27;,</span><br><span class="line">    url:&#x27;http://cache1.arcgisonline.cn/arcgis/rest/services/ChinaOnlineCommunity/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//捷泰地图(灰) ［需要纠偏］</span><br><span class="line">var geoq2Layer = new ol.layer.Tile(&#123;</span><br><span class="line">  source: new ol.source.XYZ(&#123;</span><br><span class="line">    crossOrigin: &#x27;anonymous&#x27;,</span><br><span class="line">    url:&#x27;http://cache1.arcgisonline.cn/ArcGIS/rest/services/ChinaOnlineStreetGray/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">//捷泰地图（深蓝） ［需要纠偏］</span><br><span class="line">var geoqLayer = new ol.layer.Tile(&#123;</span><br><span class="line">  source: new ol.source.XYZ(&#123;</span><br><span class="line">    crossOrigin: &#x27;anonymous&#x27;,</span><br><span class="line">    url:&#x27;http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetPurplishBlue/MapServer/tile/&#123;z&#125;/&#123;y&#125;/&#123;x&#125;&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="地理空间数据格式"><a href="#地理空间数据格式" class="headerlink" title="地理空间数据格式"></a>地理空间数据格式</h3><p><a href="http://www.voidcn.com/article/p-spkzwblm-bpe.html">OGC简单要素标准（WKT/WKB）</a><br><a href="https://www.osgeo.cn/pygis/others-geojson.html">Python下面其他开源GIS库的使用(GeoJson)</a><br><a href="https://www.jianshu.com/p/852d7ad081b3">GEOJSON标准格式学习</a><br><a href="https://www.jianshu.com/p/d78fff321005">GeoJSON与WKT、WKB字符串</a></p><p>数据格式类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POINT(6 10)</span><br><span class="line">LINESTRING(3 4,10 50,20 25)</span><br><span class="line">POLYGON((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2))</span><br><span class="line">MULTIPOINT(3.5 5.6, 4.8 10.5)</span><br><span class="line">MULTILINESTRING((3 4,10 50,20 25),(-5 -8,-10 -8,-15 -4))</span><br><span class="line">MULTIPOLYGON(((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2)),((6 3,9 2,9 4,6 3)))</span><br><span class="line">GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))</span><br><span class="line">POINT ZM (1 1 5 60)</span><br><span class="line">POINT M (1 1 80)</span><br><span class="line">POINT EMPTY</span><br><span class="line">MULTIPOLYGON EMPTY</span><br></pre></td></tr></table></figure><p>关于坐标系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">坐标系：</span><br><span class="line"> 3857 google</span><br><span class="line"> 4326 WGS-84：是国际标准，GPS坐标（Google Earth使用、或者GPS模块）</span><br><span class="line"> 2437 GCJ-02：中国坐标偏移标准，Google Map、高德、腾讯使用</span><br><span class="line"> BD-09：百度坐标偏移标准，Baidu Map使用</span><br><span class="line">坐标系转换</span><br><span class="line"> &#x27;EPSG:4326&#x27; - 经纬度坐标-WGS84</span><br><span class="line"> &#x27;EPSG:3857&#x27; - xy坐标-web墨卡托</span><br><span class="line">openlayers 默认的坐标系为 EPSG:3857</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/wangweigang689/article/details/105778722">https://blog.csdn.net/wangweigang689/article/details/105778722</a></p><p>行政区划代码，地区 <a href="https://www.likecs.com/show-246916.html">https://www.likecs.com/show-246916.html</a></p><h3 id="GeoTools-amp-openlayers"><a href="#GeoTools-amp-openlayers" class="headerlink" title="GeoTools &amp; openlayers"></a>GeoTools &amp; openlayers</h3><p><a href="https://segmentfault.com/a/1190000020297846">Openlayers API整理</a><br><a href="https://openlayers.org/">openlayer</a><br><a href="http://docs.geotools.org/latest/userguide/library/jts/index.html">GeoTools</a><br><a href="http://docs.geotools.org/stable/userguide/">Geotools user guide</a><br><a href="https://www.cnblogs.com/qingtian-jlj/p/12988219.html">WKT(Well-known text)是开放地理空间联盟OGC（Open GIS Consortium ）制定的一种文本标记语言，用于表示矢量几何对象、空间参照系统及空间参照系统之间的转换</a></p><h3 id="分布式架构优化"><a href="#分布式架构优化" class="headerlink" title="分布式架构优化"></a>分布式架构优化</h3><p>分布式框架<br>    Dubbo<br>    shardingsphere<br>    Netty<br>分布式消息中间间<br>    Rabbitmq<br>    RocketMq<br>    kafka<br>分布式存储中间件<br>    Redis<br>    MongoDB<br>    FastDFS<br>    Elasticserch</p><p><a href="https://www.bilibili.com/video/BV1cL411b77R">B站最全面分布式面试100道（涵盖所有分布式核心面试知识点）</a><br><a href="https://www.bilibili.com/video/BV1aJ411Y73e">分布式架构学习视频全集|图灵周瑜 </a><br><a href="https://www.bilibili.com/video/BV1Hy4y117op">分布式架构全套教程（700分钟干货精讲）</a><br><a href="https://www.bilibili.com/video/BV1tq4y1D7Kb">超全面深入讲解Java虚拟机 </a><br><a href="https://www.bilibili.com/video/BV1gh411z7kJ">分布式文件系统FastDFS入门到实战 </a><br><a href="https://www.bilibili.com/video/BV1nb4y1974r">Tomcat与Nginx负载均衡底层原理分析 </a></p><p><a href="https://www.cnblogs.com/FlyAway2013/p/11201250.html">Nacos 集群部署 </a><br><a href="https://www.cnblogs.com/yuuje/p/11005992.html">nginx如何配置负载均衡</a></p><h3 id="大数据分布式架构"><a href="#大数据分布式架构" class="headerlink" title="大数据分布式架构"></a>大数据分布式架构</h3><p><a href="https://cloud.tencent.com/developer/article/1881291">软件架构设计分层模型和构图思考</a><br><a href="https://cloud.tencent.com/developer/article/1049174">中国联通大数据能力开放平台容器化实践</a><br><a href="https://cloud.tencent.com/developer/article/1540779">运维产品的能力闭环体系</a><br><a href="https://cloud.tencent.com/developer/article/1897347">研发平台演进：从工具链到开放平台</a><br><a href="https://cloud.tencent.com/developer/article/1702031">业务系统组件化开发概述和技术架构设计</a></p><p><a href="https://cloud.tencent.com/developer/article/1832221">产品高阶能力：架构图的设计与画法</a><br><a href="https://cloud.tencent.com/developer/article/1518589">怎样成为一个优秀的架构师？</a><br><a href="https://cloud.tencent.com/developer/article/1533354">直击架构本质：优秀架构师必须掌握的几种架构思维</a><br><a href="https://cloud.tencent.com/developer/article/1561345">系统化服务构建-软件工程分层</a></p><h3 id="贷款材料"><a href="#贷款材料" class="headerlink" title="贷款材料"></a>贷款材料</h3><p>贷款额度计算材料（预审材料）：<br>夫妻双方身份证<br>征信证明<br>户口本<br>异地缴存证明</p><p>公积金贷款需要材料：<br>夫妻双方身份证 原件、复印件一份<br>户口本  原件、复印件一份<br>结婚证 原件及复印件一份<br>夫妻双方（一个月内）征信报告<br>售房单位网签备案的商品房买卖合同<br>售房单位出具的首付款的发票 原件及复印件一份<br>银行卡（开发商要求的汇款银行的） 原件及复印件一份<br>异地贷款缴存使用证明</p><h3 id="CSS-书写规范"><a href="#CSS-书写规范" class="headerlink" title="CSS 书写规范"></a>CSS 书写规范</h3><p><a href="https://www.cnblogs.com/xuepei/p/8961809.html">CSS书写规范、顺序</a></p><h3 id="javaList进行求和、分组、提取对象单个属性列表"><a href="#javaList进行求和、分组、提取对象单个属性列表" class="headerlink" title="javaList进行求和、分组、提取对象单个属性列表"></a>javaList进行求和、分组、提取对象单个属性列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 分组</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;User&gt;&gt; collect = details.stream().collect(Collectors.groupingBy(User::getCustomerId));</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 单列求和</span><br><span class="line"><span class="keyword">int</span> totalValue = details.stream().mapToInt(User::getSmsFee).sum();</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 提取单列数据集合</span><br><span class="line">List&lt;Integer&gt; ids = details.stream().map(User::getId).collect(Collectors.toList());</span><br><span class="line">Set&lt;String&gt; accounts = details.stream().map(User::getAccount).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 按条件过滤</span><br><span class="line"><span class="comment">//按照条件过滤</span></span><br><span class="line">List&lt;User&gt; collect = list.stream().filter(u -&gt; <span class="string">&quot;北京&quot;</span>.equals(u.getAddr())).collect(Collectors.toList())</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>两个集合比较</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤符合某个集合的数据（为了比对效率，accounts不能是list，需要使用set集合）</span></span><br><span class="line">List&lt;ExamData&gt; existList = uniqueList.stream().filter(t-&gt;accounts.contains(t.getAccount())).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 去重</span><br><span class="line"><span class="comment">//按单个属性去重</span></span><br><span class="line">List&lt;InstallOrder&gt; unique = installOrderList.stream().collect(</span><br><span class="line">                    Collectors.collectingAndThen(Collectors.toCollection(()-&gt;<span class="keyword">new</span> TreeSet&lt;&gt;(Comparator.comparing(InstallOrder::getOrderCode))),ArrayList::<span class="keyword">new</span>));</span><br><span class="line">List&lt;ExamData&gt; uniqueList = data.stream().distinct().collect(Collectors.toList()); <span class="comment">//这种写法需要重写ExamData中的hasCode和equals方法</span></span><br><span class="line"><span class="comment">//ExamData hasCode和equals重写</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ExamData detail = (ExamData) obj;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == detail) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.account.equals(detail.account));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashno = <span class="number">7</span>;</span><br><span class="line">    hashno = <span class="number">13</span> * hashno + (account == <span class="keyword">null</span> ? <span class="number">0</span> : account.hashCode());</span><br><span class="line">    <span class="keyword">return</span> hashno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="mybatis-使用hikari-驱动读取全量数据"><a href="#mybatis-使用hikari-驱动读取全量数据" class="headerlink" title="mybatis 使用hikari 驱动读取全量数据"></a>mybatis 使用hikari 驱动读取全量数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Transactional Cursor mybatis游标方式必须设置事务否则执行报错。</span></span><br><span class="line"><span class="comment">//2，druid 连接池不支持 mybatis 游标方式。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ExamData&gt; <span class="title">getExamData</span><span class="params">(String cityName, String opMonth)</span> </span>&#123;</span><br><span class="line">    List&lt;ExamData&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> (Cursor&lt;ExamData&gt; cursor = deatilMapper.findByCity4Cursor(cityName, opMonth)) &#123;</span><br><span class="line">        cursor.forEach(foo -&gt; &#123;list.add(foo); &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Select(&quot;&lt;script&gt;&quot; +</span></span><br><span class="line"><span class="meta">        &quot;select &quot; +</span></span><br><span class="line"><span class="meta">        &quot;   id id,\n&quot; +</span></span><br><span class="line"><span class="meta">        &quot;   op_month opMonth,\n&quot; +</span></span><br><span class="line"><span class="meta">        &quot;   city_name cityName,\n&quot; +</span></span><br><span class="line"><span class="meta">        &quot;   ... \n&quot; +</span></span><br><span class="line"><span class="meta">        &quot; from ZS_EXAM_DETAIL &quot; +</span></span><br><span class="line"><span class="meta">        &quot;&lt;where&gt; &quot; +</span></span><br><span class="line"><span class="meta">        &quot;   OP_MONTH=#&#123;opMonth&#125; and city_name=#&#123;cityName&#125;&quot; +</span></span><br><span class="line"><span class="meta">        &quot;&lt;/where&gt;&quot; +</span></span><br><span class="line"><span class="meta">        &quot;&lt;/script&gt;&quot;)</span></span><br><span class="line"><span class="meta">@Options(fetchSize = 1000)</span></span><br><span class="line"><span class="function">Cursor&lt;ExamData&gt; <span class="title">findByCity4Cursor</span><span class="params">(<span class="meta">@Param(&quot;cityName&quot;)</span> String cityName,<span class="meta">@Param(&quot;opMonth&quot;)</span> String opMonth)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Arduino资料"><a href="#Arduino资料" class="headerlink" title="Arduino资料"></a>Arduino资料</h3><p><a href="https://www.arduino.cn/thread-1066-1-1.html">https://www.arduino.cn/thread-1066-1-1.html</a></p><h3 id="在线文档"><a href="#在线文档" class="headerlink" title="在线文档"></a>在线文档</h3><p><a href="https://docs.oracle.com/en/java/javase/11/">java11文档</a><br><a href="https://www.mklab.cn/api/jdk/11/cn">java11中文</a><br><a href="https://www.apiref.com/java11-zh/index.html">java11中文-备份</a><br><a href="https://docs.oracle.com/en/java/javase/11/docs/api/">java11英文</a></p><p><a href="https://www.mklab.cn/api/jdk/8/cn">java8中文</a><br><a href="https://www.matools.com/api/java8">java8中文2</a><br><a href="https://docs.oracle.com/javase/8/docs/api/">java8英文</a></p><p><a href="http://www.redis.cn/documentation.html">Redis中文1</a><br><a href="https://www.redis.net.cn/tutorial/3501.html">Redis中文2</a></p><p><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/htmlsingle">spring-boot</a><br><a href="https://www.apiref.com/spring-boot-zh/">spring-boot中文</a></p><p><a href="https://www.springcloud.cc/spring-cloud-brixton.html">Spring Cloud中文</a><br><a href="https://docs.spring.io/spring-cloud/docs/Hoxton.SR12/reference/html/">Spring Cloud Hoxton.SR12(springboot 2.3.12.RELEASE)</a></p><p><a href="https://www.apiref.com/kubernetes-zh/index.html">Kubernetes(K8S)中文文档_Kubernetes中文社区</a><br><a href="https://www.docker.org.cn/book/docker/what-is-docker-16.html">docker入门教程</a><br><a href="https://www.runoob.com/docker/docker-tutorial.html">docker教程</a><br><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">Elasticsearch: 权威指南</a></p><p><a href="https://openlayers.org/en/latest/apidoc/">openlayers文档</a><br><a href="http://docs.geotools.org/stable/userguide/index.html">geotools文档</a><br><a href="https://docs.geotools.org/stable/javadocs/">geotools api</a><br><a href="http://locationtech.github.io/jts/javadoc/index.html">JTS api</a></p><p><a href="https://www.cnblogs.com/xiaxiaolu/p/13514915.html">聊聊常见的服务(接口)认证授权</a><br><a href="https://www.cnblogs.com/joy99/p/10941543.html">Spring AOP——Spring 中面向切面编程</a><br><a href="https://blog.csdn.net/qq_38496561/article/details/105945386">Spring Boot Admin+Nacos从入门到上线</a><br><a href="https://www.jianshu.com/p/05ee63c5b932">Nacos整合Spring Boot Admin</a><br><a href="http://www.uml.org.cn/wfw/2020041312.asp">微服务环境搭建</a></p><h3 id="RSIC-V"><a href="#RSIC-V" class="headerlink" title="RSIC-V"></a>RSIC-V</h3><p><a href="https://gitee.com/liangkangnan/tinyriscv#https://liangkangnan.gitee.io/2020/04/29/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99RISC-V%E5%A4%84%E7%90%86%E5%99%A8/">从零开始写RISC-V处理器</a><br><a href="">Verilog HDL</a></p><h3 id="springboot-cloud-示例"><a href="#springboot-cloud-示例" class="headerlink" title="springboot cloud 示例"></a>springboot cloud 示例</h3><p><a href="https://gitee.com/matevip">MateCloud微服</a></p><h3 id="计算机类书目"><a href="#计算机类书目" class="headerlink" title="计算机类书目"></a>计算机类书目</h3><p>1.计算机科学概论</p><p>计算机科学概论<br>计算机系统概论(2016/11/27)<br>计算机系统要素(2016/11/27)</p><p>2.计算机数学基础</p><p>高等数学线性代数<br>概率论与数理统计<br>离散数学及其应用<br>离散数学教程(北大版)<br>什么是数学<br>具体数学：计算机科学基础</p><p>3.C语言</p><p>C primer plusThe C programming language<br>C和指针<br>C专家教程<br>C陷阱与缺陷<br>c语言解惑<br>C标准库<br>你必须知道的495个C语言问题</p><p>4.算法与数据结构</p><p>数据结构(清华版)数据结构与算法分析—C语言描述<br>C算法(第一卷:基础、数据结构、排序和搜索)<br>C算法(第二卷 图算法)<br>编程珠玑<br>编程珠玑II(More programming Pearls)<br>算法概论 2014-2-8</p><p>算法第4版红皮书(2016/11/27)</p><p>算法导论计算机程序设计艺术卷1<br>计算机程序设计艺术卷2<br>计算机程序设计艺术卷3</p><p>5.电子技术基础</p><p>模拟电子技术(童诗白版)<br>数字逻辑与数字集成电路(清华版)</p><p>6.汇编语言</p><p>汇编语言(王爽版)80X86汇编语言程序设计教程<br>Intel汇编语言程序设计<br>IBM PC汇编语言程序设计(国外版)<br>高级汇编语言程序设计<br>保护方式下的80386及其编程<br>黑客反汇编揭秘<br>Windows.环境下32位汇编语言程序设计(第2版)<br>汇编语言程序设计+基于ARM体系结构</p><p>7.计算机硬件原理</p><p>计算机组成-结构化方法微机原理与接口技术(陈光军版)<br>计算机体系结构(张晨曦版)<br>计算机组成与设计硬件/软件接口<br>Intel微处理器结构、编程与接口<br>计算机体系结构(量化研究方法)<br>编程卓越之道卷1<br>编程卓越之道卷2<br>深入理解计算机系统<br>编码的奥秘</p><p>8.数据库系统原理</p><p>数据库系统概念数据库系统导论<br>数据库系统实现</p><p>9.编译原理</p><p>编译原理(清华第2版)编译原理及实践<br>编译原理:原则,技术和工具<br>现代编译原理-C语言描述<br>高级编译器设计与实现</p><p>10.操作系统原理</p><p>操作系统概念现代操作系统<br>链接器和加载器<br>程序员的自我修养:链接、装载与库<br>自己动手写操作系统<br>操作系统设计与实现</p><p>11.计算机网络</p><p>计算机网络(Computer Networks)TCP-IP详解卷1<br>TCP-IP详解卷2<br>TCP-IP详解卷3<br>用TCP/IP进行网际互联(第一卷):原理、协议与结构<br>用TCP/IP进行网际互联第二卷：设计、实现与内核(第三版)<br>用TCP/IP 进行网际互联第三卷:客户-服务器编程与应用</p><p>12.软件工程和面向对象程序设计</p><p>C++编程思想卷<br>java编程思想<br>软件工程(Software.Engineering)<br>软件工程：实践者的研究方法<br>深入浅出面向对象分析与设计<br>head first设计模式<br>道法自然:面向对象实践指南<br>面向对象分析与设计<br>敏捷软件开发：原则、模式与实践<br>设计模式:可复用面向对象软件的基础<br>测试驱动开发<br>重构—改善既有代码的设计<br>代码大全<br>程序设计实践<br>程序员修炼之道：从小工到专家<br>卓有成效的程序员<br>代码之美<br>人月神话<br>计算机程序的构造和解释<br>观止-微软创建NT和未来的夺命狂奔<br>代码优化：有效使用内存[美]克里斯·卡巴斯基<br>编程高手箴言(梁肇新)<br>游戏之旅-我的编程感悟(云风)<br>企业应用架构模式</p><p>修改代码的艺术</p><p>xUnit.Test.Patterns.Refactoring.Test.Code</p><p>13.windows编程基础</p><p>Windows操作系统原理Inside Windows 2000<br>深入解析Windows操作系统<br>天书夜读：从汇编语言到Windows内核编程<br>windows程序设计<br>WINDOWS核心编程</p><p>14.linux/unix编程基础</p><p>鸟哥的Linux私房菜:基础学习篇鸟哥的Linux私房菜:服务器架设篇<br>linux程序设计<br>UNIX环境高级编程<br>Unix网络编程卷1<br>UNIX网络编程卷2<br>UNIX编程艺术<br>UNIX Shell范例精解<br>The Linux Programming Interface - A Linux and UNIX System Programming Handbook</p><p>15.Linux/unix内核源代码和驱动程序</p><p>Linux内核设计与实现LINUX内核源代码情景分析<br>深入理解LINUX内核<br>Linux内核完全注释<br>Linux设备驱动程序<br>深入Linux设备驱动程序内核机制<br>深入Linux内核架构<br>精通Linux设备驱动程序开发<br>Linux设备驱动开发详解</p><p>16.C++语言</p><p>C++编程思想2Essential C++<br>C++ primer<br>C++程序设计语言<br>C++语言的设计和演化<br>Accelerated C++<br>Effective C++<br>More Effective C++<br>Exceptional C++<br>More Exceptional C++<br>C++设计新思维<br>深度探索C++对象模型<br>C++沉思录<br>C++ Templates: The Complete Guide<br>C++ FAQs</p><p>17.标准库STL使用<br>C++标准程序库Effective STL<br>泛型编程与STL<br>18.STL源代码<br>STL源码剖析</p><p>19.java语言<br>java编程思想Java编程规范(The Java Language Specification)<br>Beginning Java(C#) Objects从概念到代码<br>effective java<br>Java解惑<br>Java性能优化权威指南<br>深入理解Java虚拟机<br>Java并发编程实践</p><p>20.图形学/分布式/机器学习<br>计算机图形学(第三版)<br>大数据时代<br>多处理器编程的艺术<br>冈萨雷斯数字图像处理(</p><p>（1）深入理解计算机系统(原书第3版).pdf<br>（2）计算机科学导论(第2版).pdf<br>（3）计算机科学概论(原书第5版).pdf</p><p>（4）C程序设计语言(第2版 新版).pdf<br>（9）C陷阱与缺陷(第2版)-人民邮电出版社.pdf<br>（13）More Effective C++.pdf<br>（14）C++编程思想(两卷合订本).pdf<br>（15）C++标准程序库(中文版).pdf<br>（16）Exceptional C++ Style中文版.pdf<br>（17）More Exceptional C++中文版.pdf</p><p>（18）Head First Java(第2版)中文版.pdf<br>（19）Java编程思想(第4版).pdf<br>（20）Java核心技术 卷1 基础知识(第10版).pdf<br>（21）Effective Java中文版(原书第3版).pdf</p><p>（22）Python学习手册(第4版).pdf<br>（23）笨办法 学Python(第4版).pdf<br>（24）Python核心编程(第3版)中文版.pdf<br>（26）流畅的Python.pdf</p><p>（27）算法导论(原书第3版).pdf<br>（28）计算机程序设计艺术 卷1：基本算法.pdf<br>（28）计算机程序设计艺术 卷2：半数值算法.pdf<br>（29）计算机程序设计艺术 卷3：排序与查找.pdf<br>（30）算法(第4版)中文版.pdf<br>（31）数据结构与算法分析 C语言描述(原书第2版).pdf<br>（32）算法竞赛入门经典(第2版).pdf</p><p>（33）编译原理(龙书)中文版.pdf<br>（34）现代编译原理 C语言描述.pdf<br>（35）高级编译器设计与实现(鲸书)中文版.pdf</p><p>（36）计算机网络 Andrew S.Tanenbaum(第四版).pdf<br>（37）计算机网络 自顶向下方法(英文第6版).pdf<br>（37）计算机网络 自顶向下方法(原书第6版).pdf<br>（37）计算机网络 自顶向下方法(中文第4版).pdf<br>（38）TCP IP详解 卷1：协议(原书第2版).pdf<br>（39）TCP IP详解 卷2：实现.pdf</p><p>（41）现代操作系统(第三版).pdf<br>（42）鸟哥的Linux私房菜(第四版).pdf<br>（44）UNIX环境高级编程(第二版).pdf<br>（44）UNIX环境高级编程(第三版).pdf<br>（45）深入理解Linux内核(第三版)中文版.pdf</p><p>（46）Pattern Recognition and Machine Learning.pdf<br>（47）Machine Learning A Probabilistic Perspective.pdf<br>（48）机器学习 Tom M.Mitchell.pdf<br>（49）机器学习 周志华.pdf<br>（50）统计自然语言处理基础(中文版).pdf<br>（51）DEEP LEARNING 深度学习 花书.pdf</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;使用技术纪录&quot;&gt;&lt;a href=&quot;#使用技术纪录&quot; class=&quot;headerlink&quot; title=&quot;使用技术纪录&quot;&gt;&lt;/a&gt;使用技术纪录&lt;/h2&gt;&lt;h3 id=&quot;百度指定网站搜索&quot;&gt;&lt;a href=&quot;#百度指定网站搜索&quot; class=&quot;headerlink&quot; title=&quot;百度指定网站搜索&quot;&gt;&lt;/a&gt;百度指定网站搜索&lt;/h3&gt;&lt;p&gt;site:(jianshu.com) WKT&lt;/p&gt;
&lt;h3 id=&quot;在线工具站点&quot;&gt;&lt;a href=&quot;#在线工具站点&quot; class=&quot;headerlink&quot; title=&quot;在线工具站点&quot;&gt;&lt;/a&gt;在线工具站点&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://tooltt.com/yaml2properties/&quot;&gt;yaml转properties&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.box3.cn/tools/lbs.html&quot;&gt;经纬度距离计算&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术积累" scheme="https://groupfusion.github.io/tags/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>系统设计面试问题</title>
    <link href="https://groupfusion.github.io/2020/09/15/dev/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>https://groupfusion.github.io/2020/09/15/dev/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</id>
    <published>2020-09-15T07:41:20.000Z</published>
    <updated>2023-12-18T01:20:27.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统设计面试问题–您应该知道的概念（转载）"><a href="#系统设计面试问题–您应该知道的概念（转载）" class="headerlink" title="系统设计面试问题–您应该知道的概念（转载）"></a>系统设计面试问题–您应该知道的概念（转载）</h2><p>转至 <a href="https://www.freecodecamp.org/news/systems-design-for-interviews">System Design Interview</a></p><p>您可能已经听说过“架构”或“系统设计”这两个术语。在开发人员工作面试中，尤其是在大型科技公司中，这些问题很多。</p><p>通过指导您基本的软件体系结构概念，本深入指南将帮助您为系统设计面试做准备。</p><p>这不是详尽的方法，因为系统设计是一个广泛的主题。但是，如果您是初级或中级开发人员，这应该为您奠定坚实的基础。</p><p>从那里，您可以深入挖掘其他资源。我在本文的底部列出了一些我最喜欢的资源。  </p><p>我已按主题将本指南分成几小部分，因此建议您将其添加为书签。我发现<a href="https://www.freecodecamp.org/news/use-spaced-repetition-with-anki-to-learn-to-code-faster-7c334d448c3c/">间隔学习和重复学习</a>是学习和保留信息的极有价值的工具。而且我已将本指南设计为易于分解的片段。</p><ol><li><a href="/#%E7%AC%AC1%E8%8A%82%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8D%8F%E8%AE%AE">第1节：网络和协议（IP，DNS，HTTP，TCP等）</a></li><li><a href="/#%E7%AC%AC2%E8%8A%82%EF%BC%9A%E5%AD%98%E5%82%A8%EF%BC%8C%E5%BB%B6%E8%BF%9F%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F">第2节：存储，延迟和吞吐量</a></li><li><a href="/%E7%AC%AC3%E8%8A%82%EF%BC%9A%E5%8F%AF%E7%94%A8%E6%80%A7">第3节：可用性</a></li><li><a href="/#%E7%AC%AC4%E8%8A%82%EF%BC%9A%E7%BC%93%E5%AD%98">第4节：缓存</a></li><li><a href="/#%E7%AC%AC5%E8%8A%82%EF%BC%9A%E4%BB%A3%E7%90%86">第5节：代理</a></li><li><a href="/#%E7%AC%AC6%E8%8A%82%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1">第6节：负载平衡</a></li><li><a href="/#%E7%AC%AC7%E8%8A%82%EF%BC%9A%E4%B8%80%E8%87%B4%E7%9A%84%E5%93%88%E5%B8%8C">第7节：一致的哈希</a></li><li><a href="/#%E7%AC%AC8%E8%8A%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93">第8节：数据库</a></li><li><a href="/#%E7%AC%AC9%E8%8A%82%EF%BC%9A%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE">第9节：领导人选举</a></li><li><a href="/#%E7%AC%AC10%E8%8A%82%EF%BC%9A%E8%BD%AE%E8%AF%A2%EF%BC%8C%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%EF%BC%8C%E5%A5%97%E6%8E%A5%E5%AD%97">第10节：轮询，流式传输，套接字</a></li><li><a href="/#%E7%AC%AC11%E8%8A%82%EF%BC%9A%E7%AB%AF%E7%82%B9%E4%BF%9D%E6%8A%A4">第11节：端点保护</a></li><li><a href="/#%E7%AC%AC12%E8%8A%82%EF%BC%9A%E6%B6%88%E6%81%AF%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85">第12节：消息和发布订阅</a></li><li><a href="/#%E7%AC%AC13%E8%8A%82%EF%BC%9A%E8%BE%83%E5%B0%8F%E7%9A%84%E5%BF%85%E9%9C%80%E5%93%81">第13节：较小的必需品</a></li></ol><p>让我们开始吧！</p><h2 id="第1节：网络和协议"><a href="#第1节：网络和协议" class="headerlink" title="第1节：网络和协议"></a>第1节：网络和协议</h2><p>“协议”是一个花哨的单词，在英语中的含义完全独立于计算机科学。这意味着可以管理某些事物的规章制度。一种“官方程序”或“必须完成某些事情的官方方式”。</p><p>为了使人们连接到彼此通信的机器和代码，他们需要一个可以在其上进行通信的网络。但是沟通也需要一些规则，结构和商定的程序。</p><p>因此，网络协议是控制机器和软件如何通过给定网络进行通信的协议。网络的一个例子是我们钟爱的万维网。</p><p>您可能听说过互联网时代最常见的网络协议-例如HTTP，TCP / IP等。让我们将它们分解为基本概念。</p><h3 id="IP-互联网协议"><a href="#IP-互联网协议" class="headerlink" title="IP-互联网协议"></a>IP-<a href="https://en.wikipedia.org/wiki/Internet_Protocol">互联网协议</a></h3><p>将此视为协议的基本层。这是基本协议，可指导我们如何实现几乎所有跨Internet网络的通信。</p><p>IP上的消息通常以“数据包”形式进行通信，这些信息包是一小束信息（2 ^ 16字节）。每个数据包都有一个由两个部分组成的<a href="https://en.wikipedia.org/wiki/IPv4#Packet_structure">基本结构</a>：标头和数据。</p><p>标头包含有关数据包及其数据的“元”数据。该元数据包括诸如源（数据包来自何处）的IP地址和目标IP地址（数据包的目的地）之类的信息。显然，这是能够将信息从一个点发送到另一点的基础-您需要“发件人”和“收件人”地址。  </p><p>和一个<a href="https://en.wikipedia.org/wiki/IP_address">IP地址</a>是分配给连接到每个设备的数值标签<a href="https://en.wikipedia.org/wiki/Computer_network">计算机网络</a>使用因特网协议进行通信。有公用和专用IP地址，当前有两个版本。新版本称为IPv6，由于IPv4的数字地址用完了，因此越来越多地被采用。</p><p>我们将在本文中考虑的其他协议是基于IP构建的，就像您最喜欢的软件语言在其之上构建的库和框架一样。  </p><h3 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP-传输控制协议"></a>TCP-<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">传输控制协议</a></h3><p>TCP是建立在IP之上的实用程序。正如您可以从阅读我的文章知道，我坚信你需要理解<em>为什么</em>东西才能被发明真正了解<em>什么</em>它。</p><p>创建TCP是为了解决IP问题。IP上的数据通常以多个数据包发送，因为每个数据包都非常小（2 ^ 16字节）。多个数据包可能导致（A）丢失或丢失的数据包，以及（B）无序的数据包，从而损坏传输的数据。TCP通过保证以<em>有序</em>方式<em>传输</em>数据包来解决这两种情况。  </p><p>数据包基于IP构建，除了IP报头之外，还具有称为TCP报头的报头。此TCP头包含有关数据包顺序和数据包数量等信息。这样可以确保在另一端可靠地接收数据。由于它建立在IP之上，因此通常称为TCP / IP。</p><p>TCP需要先在源和目标之间建立连接，然后再通过“握手”进行连接。此连接本身是使用数据包建立的，其中源将其通知目的地它想打开连接，并且目的地说“确定”，然后打开连接。</p><p>实际上，这就是服务器在端口“侦听”时发生的情况-在它开始侦听之前，先握手，然后打开连接（侦听开始）。类似地，一个向另一个发送一条消息，即将关闭连接，并结束连接。  </p><h3 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP-超文本传输协议"></a>HTTP-<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">超文本传输协议</a></h3><p>HTTP是一种协议，是基于TCP / IP构建的抽象。它引入了一个非常重要的模式，称为请求-响应模式，专门用于客户端-服务器交互。  </p><p>客户端只是请求信息的机器或系统，而服务器是响应信息的机器或系统。浏览器是客户端，而网络服务器是服务器。当服务器从另一台服务器请求数据时，第一台服务器也是客户端，第二台服务器是服务器（我知道是重言式）。</p><p>因此，此请求-响应周期在HTTP下具有其自己的规则，这标准化了信息在Internet上的传输方式。  </p><p>在这种抽象级别上，我们通常不需要太担心IP和TCP。但是，在HTTP中，请求和响应也具有标头和正文，并且标头和正文包含开发人员可以设置的数据。</p><p>HTTP请求和响应可以被视为具有键-值对的消息，与JavaScript中的对象和Python中的字典非常相似，但不相同。</p><p>下图说明了HTTP请求和响应消息中的内容和键值对。</p><p><img src="https://www.freecodecamp.org/news/content/images/2020/03/image-44.png" alt="img">来源：<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages">https</a> : <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages">//developer.mozilla.org/en-US/docs/Web/HTTP/Messages</a></p><p>HTTP还带有一些“动词”或“方法”，这些命令是使您了解打算执行哪种操作的命令。例如，常见的HTTP方法是“ GET”，“ POST”，“ PUT”，“ DELETE”和“ PATCH”，但还有更多方法。在上图中，在起始行中查找HTTP动词。</p><h2 id="第2节：存储，延迟和吞吐量"><a href="#第2节：存储，延迟和吞吐量" class="headerlink" title="第2节：存储，延迟和吞吐量"></a>第2节：存储，延迟和吞吐量</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>存储是关于保存信息的。您编程的任何应用程序，系统或服务都将需要存储和检索数据，而这是存储的两个基本目的。</p><p>但这不只是存储数据，还在于获取数据。我们使用数据库来实现这一目标。数据库是帮助我们存储和检索数据的软件层。</p><p>这两种主要的操作类型，即存储和检索，也分别称为“设置，获取”，“存储，获取”，“写入，读取”等。要与存储进行交互，您将需要遍历数据库，该数据库充当您执行这些基本操作的中介。</p><p>“存储”一词有时会使我们从物理角度上去思考它。如果我将自行车“存放”在棚子里，那么我下次打开棚子时可以期望它在那里。</p><p>但这并不总是在计算世界中发生。存储大致可以分为两种类型：“内存”存储和“磁盘”存储。  </p><p>在这两个磁盘中，磁盘存储趋向于更健壮和“永久”（不是真正的永久，因此我们经常使用“永久”存储一词）。磁盘存储是持久性存储。这意味着，当您将某些内容保存到磁盘，然后关闭电源或重新启动服务器时，该数据将“持续存在”。它不会丢失。</p><p>但是，如果将数据保留在“内存”中，那么通常在关闭或重新启动时这些数据会消失，否则会断电。  </p><p>您每天使用的计算机都具有这两种存储类型。您的硬盘是<br>“永久性”磁盘存储，而您的RAM是暂时性的内存存储。</p><p>在服务器上，如果您跟踪的数据仅在该服务器的会话期间有用，则将其保留在内存中是有意义的。与将内容写入持久数据库相比，这要快得多且成本更低。</p><p>例如，单个会话可能意味着用户登录并使用您的网站。他们注销后，您可能不需要保留在会话期间收集的部分数据。</p><p>但是，无论您想保留什么（例如购物车历史记录），您都将放入永久性磁盘存储中。这样，您可以在用户下次登录时访问该数据，他们将获得无缝的体验。</p><p>好的，这看起来非常简单和基本，而且确实如此。这是入门。存储会变得非常复杂。如果您看一下存储产品和解决方案的范围，您的头会旋转。</p><p>这是因为不同的用例需要不同的存储类型。它们为系统选择正确的存储类型的关键取决于许多因素，应用程序的需求以及用户如何与之交互。其他因素包括：</p><ul><li>数据的形状（结构），或</li><li>它需要什么样的可用性（哪种水平的停机时间适合您的存储），或者</li><li>可伸缩性（您需要多快读写数据，这些读写将同时（同时）或顺序进行）等，或</li><li>一致性-如果您使用分布式存储来防止停机，那么整个存储中的数据的一致性如何？</li></ul><p>这些问题和结论要求您仔细考虑您的取舍。一致性比速度重要吗？您需要该数据库每分钟执行数百万次操作还是仅用于每晚更新？稍后我将在各节中处理这些概念，所以如果您不知道它们是什么，请不要担心。</p><h3 id="潜伏"><a href="#潜伏" class="headerlink" title="潜伏"></a>潜伏</h3><p>当您开始在设计系统以支持应用程序的前端方面获得更多经验时，您会经常听到“延迟”和“吞吐量”这两个术语。它们对于您的应用程序和整个系统的体验和性能至关重要。通常倾向于以比预期更广泛的含义使用这些术语，或者超出上下文使用，但让我们对其进行修复。</p><p><strong>延迟</strong>只是持续时间的度量。什么时间 完成某件事或产生结果的动作的持续时间。例如：数据从系统中的一个位置移动到另一个位置。您可能会认为这是一个滞后，或者仅仅是完成操作所花费的时间。</p><p>最常见的延迟是“往返”网络请求-前端网站（客户端）向服务器发送查询并从服务器返回响应需要多长时间。  </p><p>加载网站时，您希望它尽可能快和流畅。换句话说，你需要<em>低</em>时延。快速查找意味着低延迟。因此，在元素数组中查找值比在哈希表中查找值要慢（延迟较高，因为您需要遍历数组中的每个元素以找到所需的元素）（延迟较低，因为您只需看一下即可）通过使用密钥在“固定”时间内更新数据（无需迭代）。  </p><p>同样，从内存中读取要比从磁盘中读取快得多（<a href="https://stackoverflow.com/questions/1371400/how-much-faster-is-the-memory-usually-than-the-disk">在此处</a>了解更多<em>）。</em>但是两者都有延迟，您的需求将决定您选择哪种数据的存储类型。</p><p>从这个意义上讲，延迟是速度的倒数。您想要更高的速度，并且想要更低的延迟。速度（尤其是通过HTTP进行的网络呼叫）的速度也取决于距离。因此，<a href="https://wondernetwork.com/pings/London">从伦敦到另一个城市的延迟时间</a>将受到与伦敦的距离的影响。</p><p>可以想象，您希望设计一个系统来避免对远程服务器执行ping操作，但是将内容存储在内存中对于您的系统可能不可行。这些折衷使系统设计变得复杂，具有挑战性并且非常有趣！</p><p>例如，显示新闻报道的网站可能更喜欢正常运行时间和可用性，而不是加载速度，而在线多人游戏可能需要可用性<em>和</em>超低延迟。这些要求将确定支持系统特殊要求的基础结构的设计和投资。</p><h3 id="通量"><a href="#通量" class="headerlink" title="通量"></a>通量</h3><p>这可以理解为机器或系统的最大容量。它通常在工厂中用于计算装配线在一小时或一天之内可以完成的工作量，或其他时间单位。</p><p>例如，一条装配线每小时可以装配20辆汽车，这就是它的吞吐量。在计算中，它是单位时间内可以传递的数据量。因此512 Mbps互联网连接是吞吐量的度量-每秒512 Mb（兆位）。</p><p>现在想象一下freeCodeCamp的Web服务器。如果它每秒接收一百万个请求，并且只能处理800,000个请求，则其吞吐量为每秒80万。您可能最终以比特而不是请求来衡量吞吐量，因此它将是每秒N位。</p><p>在此示例中，存在<em>瓶颈，</em>因为服务器每秒处理的位数不能超过N个，但是请求的位数不止于此。因此，瓶颈是对系统的约束。一个系统的速度只有<em>最慢的瓶颈。</em>  </p><p>如果一台服务器每秒可以处理100位，另一台服务器每秒可以处理120位，而第三台服务器只能处理50位，那么整个系统将以50bps的速度运行，因为这是一个限制-它可以保持其他服务器的速度在给定的系统中。</p><p>因此，增加瓶颈以外的任何地方的吞吐量可能都是浪费–您可能只想首先在<em>最低瓶颈</em>处增加<em>吞吐量</em>。  </p><p>您可以通过购买更多硬件（水平缩放）或增加现有硬件的容量和性能（垂直缩放）或其他几种方式来提高吞吐量。</p><p>有时，增加吞吐量可能是一个短期解决方案，因此，优秀的系统设计人员将考虑通过最佳方法来扩展给定系统的吞吐量，包括通过拆分请求（或任何其他形式的“负载”）并在各个请求之间进行分配要记住的关键点是什么是吞吐量，什么是约束或瓶颈以及它如何影响系统。</p><p>固定延迟和吞吐量不是孤立的，通用的解决方案，也不是相互关联的。它们对整个系统都有影响和考虑因素，因此了解整个系统以及随时间推移对系统提出的需求的性质非常重要。</p><h2 id="第三节：系统可用性"><a href="#第三节：系统可用性" class="headerlink" title="第三节：系统可用性"></a>第三节：系统可用性</h2><p>软件工程师旨在构建可靠的系统。可靠的系统是一个始终满足用户需求的系统，只要该用户想要满足该需求。这种可靠性的关键组成部分是可用性。</p><p>将可用性视为系统的弹性很有帮助。如果系统足够健壮，可以处理网络，数据库，服务器等中的故障，则通常可以将其视为容错系统-这使其成为可用系统。  </p><p>当然，从多种意义上讲，系统是其各个部分的总和，如果可用性与站点或应用程序的最终用户体验有关，则每个部分都必须<a href="https://en.wikipedia.org/wiki/High_availability">具有高</a>可用性。</p><h3 id="量化可用性"><a href="#量化可用性" class="headerlink" title="量化可用性"></a>量化可用性</h3><p>为了量化系统的可用性，我们计算在给定的时间范围内系统主要功能和操作可用的时间百分比（正常运行时间）。</p><p>最关键业务系统将需要具有近乎完美的可用性。在高峰期，支持高变化需求和尖峰和低谷负载的系统可能会以较低的可用性摆脱困境。</p><p>这完全取决于系统的用途和性质。但是总的来说，即使是那些需求较低但始终如一或隐含保证系统“按需”的事物，也需要具有高可用性。</p><p>想想一个备份图片的网站。您并非总是需要从中访问和检索数据-主要是用于存储内容。您仍然希望每次登录下载任何图片时，它始终可用。  </p><p>在黑色星期五或网络星期一销售这样的大型电子商务购物日中，可以理解另一种类型的可用性。在这些特定日子里，需求将激增，数以百万计的人将尝试同时访问交易。这将需要极其可靠和高可用性的系统设计来支持这些负载。</p><p>高可用性的商业原因只是因为站点上的任何停机都会导致站点亏损。此外，这可能对声誉确实不利，例如，该服务是<em>其他</em>企业用来提供服务的服务。如果AWS S3出现故障，包括Netflix在内的许多公司将遭受损失，这<em>不是很好</em>。</p><p>因此，正常运行时间对于成功至关重要。值得记住的是，商业可用性数字是根据年度可用性计算得出的，因此每年0.17％（即99.9％的可用性）的停机<a href="https://en.wikipedia.org/wiki/High_availability">时间为每年8.77个小时</a>！</p><p>因此，正常运行时间非常高。通常会看到99.99％的正常运行时间（每年52.6分钟的停机时间）。这就是为什么现在通常用“ nines”（正常运行时间保证中<a href="https://en.wikipedia.org/wiki/High_availability#%22Nines%22">的九位数）</a>来指称正常运行时间。  </p><p>在当今世界上，大规模或关键任务服务是不可接受的。这就是为什么现在“五个九”被认为是理想的可用性标准的原因，因为这相当于<em>每年</em>停机时间超过5分钟。</p><h3 id="服务水平协议"><a href="#服务水平协议" class="headerlink" title="服务水平协议"></a>服务水平协议</h3><p>为了使在线服务具有竞争力并满足市场期望，在线服务提供商通常会提供服务级别协议/保证。这些是一组保证的服务级别指标。99.999％的正常运行时间就是这样一种指标，通常作为高级订阅的一部分提供。</p><p>对于数据库和云服务提供商，如果客户对该产品的核心使用证明了该指标的合理性，则即使在试用或免费套餐上也可以提供此服务。</p><p>在许多情况下，如果未能满足SLA，则客户将获得信用证或其他形式的补偿，以弥补提供商未达到该保证的权利。举例来说，这里是<a href="https://cloud.google.com/maps-platform/terms/sla">Google针对Maps API的SLA。</a></p><p>因此，在设计系统时，SLA是整个商业和技术考虑因素的关键部分。特别重要的是要考虑可用性是否实际上是系统某个部分的关键要求，以及哪些部分需要高可用性。</p><h3 id="设计HA"><a href="#设计HA" class="headerlink" title="设计HA"></a>设计HA</h3><p>因此，在设计高可用性（HA）系统时，您需要减少或消除“单点故障”。单点故障是系统中的一个元素，是<em>唯一</em>可能导致不希望的可用性损失的元素。</p><p>您可以通过在系统中设计“冗余”来消除单点故障。冗余基本上是对对高可用性至关重要的元素进行1个或多个选择（即备份）。  </p><p>因此，如果您的应用需要用户进行身份验证才能使用它，并且只有一个身份验证服务和后端，并且该服务失败了，那么，由于那是单点故障，因此您的系统不再可用。通过拥有两个或多个可以处理身份验证的服务，您增加了冗余并消除了（或减少了）单点故障。</p><p>因此，您需要了解系统并将其分解为所有部分。找出哪些可能导致单点故障，哪些不能容忍这种故障，哪些部分可以容忍它们。由于工程HA需要权衡，并且其中一些权衡在时间，金钱和资源方面可能是昂贵的。</p><h2 id="第4节：缓存"><a href="#第4节：缓存" class="headerlink" title="第4节：缓存"></a>第4节：缓存</h2><p>正在缓存！这是提高系统性能的非常基础且易于理解的技术。因此，缓存有助于减少系统中的<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#storage-latency-throughput">“等待时间”</a>。</p><p>在我们的日常生活中，我们将缓存视为常识（大部分时间…）。如果我们住在超市的隔壁，我们仍然想购买一些基本物品并将其存放在冰箱和食物柜中。这是缓存。每当我们想要食物时，我们总是可以走出去，去隔壁并购买这些东西–但是，如果它在食品室或冰箱中，我们会减少制作食物的时间。那是缓存。</p><h3 id="常见的缓存方案"><a href="#常见的缓存方案" class="headerlink" title="常见的缓存方案"></a>常见的缓存方案</h3><p>同样，就软件而言，如果我们最终经常依赖某些数据，则可能需要缓存该数据，以便我们的应用程序执行得更快。</p><p>当由于发出网络请求的延迟而从内存而不是从<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#storage-latency-throughput">磁盘</a>检索数据更快时，通常会如此。实际上，许多网站都在<a href="https://www.cloudflare.com/learning/cdn/what-is-caching/">CDN</a>中缓存（尤其是内容不经常更改的情况），以便可以更快地将其提供给最终用户，并减少了后端服务器的负载。  </p><p>缓存可以帮助您解决的另一个问题是后端必须执行一些计算量大且耗时的工作。缓存将您的查找时间从线性O（N）时间转换为恒定O（1）时间的先前结果可能会非常有优势。</p><p>同样，如果您的服务器必须进行多个网络请求和API调用才能组成发送回请求者的数据，则缓存数据可以减少网络调用的次数，从而减少延迟。</p><p>如果您的系统具有客户端（前端），服务器和数据库（后端），则可以在客户端（例如浏览器存储），客户端与服务器（例如CDN）之间或服务器本身上插入缓存。这将减少对数据库的网络调用。  </p><p>因此，缓存可以在系统中的多个点或级别上发生，包括在硬件（CPU）级别上。</p><h3 id="处理陈旧数据"><a href="#处理陈旧数据" class="headerlink" title="处理陈旧数据"></a>处理陈旧数据</h3><p>您可能已经注意到，上面的示例对于“读取”操作是隐式方便的。写入操作在主要原则上并没有什么不同，但有以下补充注意事项：</p><ul><li>写操作需要保持缓存和数据库同步</li><li>这可能会增加复杂性，因为要执行更多的操作，并且需要仔细分析有关处理未同步或“过时”数据的新注意事项</li><li>可能需要实施新的设计原则来处理该同步-应该同步还是异步完成？如果异步，那么以什么间隔？同时，从何处获取数据？缓存需要多久刷新一次，等等。</li><li>数据“逐出”或更新和刷新数据，以使缓存的数据保持最新和最新状态。这些包括<a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Last_in_first_out_(LIFO)_or_First_in_last_out_(FILO)">LIFO</a>，<a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#First_in_first_out_(FIFO)">FIFO</a>，<a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)">LRU</a>和<a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least-frequently_used_(LFU)">LFU之类的技术</a>。</li></ul><p>因此，让我们以一些概括性的，非约束性的结论作为结尾。通常，当用于存储静态或不经常更改的数据时，并且当更改的源可能是单个操作而不是用户生成的操作时，缓存效果最佳。  </p><p>在数据的一致性和新鲜度至关重要的情况下，缓存可能不是最佳的解决方案，除非系统中存在另一个可以有效刷新缓存的元素，这些间隔不会对应用程序的目的和用户体验产生不利影响。</p><h2 id="第5节：代理"><a href="#第5节：代理" class="headerlink" title="第5节：代理"></a>第5节：代理</h2><p>代理。什么？我们许多人都听说过代理服务器。我们可能已经在某些PC或Mac软件上看到了配置选项，这些选项讨论添加和配置代理服务器或“通过代理”访问。</p><p>因此，让我们了解一下相对简单，广泛使用且重要的技术。这是一个完全独立于计算机科学的英语单词，因此让我们从该<a href="https://www.merriam-webster.com/dictionary/proxy">定义</a>开始。</p><p><img src="https://www.freecodecamp.org/news/content/images/2020/03/Screen-Shot-2020-03-08-at-12.57.03-pm.png" alt="img">资料来源：<a href="https://www.merriam-webster.com/dictionary/proxy">https</a> : <a href="https://www.merriam-webster.com/dictionary/proxy">//www.merriam-webster.com/dictionary/proxy</a></p><p>现在，您可以将大部分内容从头脑中弹出，然后按住一个关键字：“替换”。  </p><p>在计算中，代理通常是服务器，并且它是充当客户端和另一台服务器之间的中间人的服务器。从字面上看，这是位于客户端和服务器之间的一些代码。这就是代理的症结所在。</p><p>如果您需要复习，或者不确定客户端和服务器的定义，则“客户端”是从另一个进程或计算机（“服务器”）请求数据的进程（代码）或计算机。当浏览器从后端服务器请求数据时，它是客户端。  </p><p>服务器为客户端提供服务，但也可以是客户端-从数据库检索数据时。然后，数据库是服务器，服务器是（数据库的）客户端，<em>也是</em>前端客户端（浏览器）的服务器。</p><p><img src="https://www.freecodecamp.org/news/content/images/2020/03/image-22.png" alt="img">来源：<a href="https://teoriadeisegnali.it/appint/html/altro/bgnet/clientserver.html#figure2">https</a>：<a href="https://teoriadeisegnali.it/appint/html/altro/bgnet/clientserver.html#figure2">//teoriadeisegnali.it/appint/html/altro/bgnet/clientserver.html#figure2</a></p><p>从上面可以看到，客户端-服务器关系是双向的。因此，客户端和服务器都是一回事。如果有一个中间人服务器接收到请求，然后将它们发送到另一个服务，然后将从另一个服务获得的响应转发回原始客户端，即代理服务器。</p><p>展望未来，我们将客户端称为客户端，将服务器称为服务器，将代理称为它们之间的事物。</p><p>因此，当客户端通过代理向服务器发送请求时，代理有时可能会掩盖客户端的身份-对于服务器，请求中通过的IP地址可能是代理而不是原始客户端。</p><p>对于那些访问网站或下载其他限制内容的人（例如从torrent网络或您所在国家/地区禁止的网站），您可能会认识到这种模式-这是建立VPN的原理。</p><p>在深入探讨之前，我想先介绍一下-通常使用的术语“代理”是指“转发”代理。转发代理是指代理在客户端与服务器之间的交互中代表客户端（代替客户端）进行操作的代理。</p><p>这有别于反向代理-反向代理代表服务器。在图中，它看起来是一样的-代理位于客户端和服务器之间，并且数据流是相同的客户端&lt;-&gt;代理&lt;-&gt;服务器。  </p><p>关键区别在于反向代理被设计为替代服务器。通常，客户甚至都不知道网络请求是通过代理路由的，并且代理将其传递给了预期的服务器（并对服务器的响应执行了相同的操作）。</p><p>因此，在正向代理中，服务器将不知道客户端的请求及其响应正在通过代理，而在反向代理中，客户端将不知道请求和响应是通过代理进行路由的。</p><p>代理感到有点偷偷摸摸:)</p><p>但是在系统设计中，特别是对于复杂系统，代理是有用的，反向代理是特别有用的。您的反向代理可以委派许多您不希望主服务器处理的任务-它可以是网守，筛选器，负载平衡器和全方位助手。</p><p>因此代理可能有用，但您可能不确定原因。同样，如果你读过我的其他的东西，你知道，我坚信你能正确地只了解事情的时候，你知道<em>为什么</em>他们的存在-知道<em>什么</em>，他们做的是不够的。  </p><p>我们已经谈到的VPN（用于转发代理）和负载平衡（反向代理服务器），但也有更多的例子<a href="https://www.quora.com/What-are-the-different-uses-of-proxy-servers">在这里</a>-我特别推荐克拉拉Clarkson的高度概括。</p><h2 id="第6节：负载平衡"><a href="#第6节：负载平衡" class="headerlink" title="第6节：负载平衡"></a>第6节：负载平衡</h2><p>如果您考虑一下负载和平衡这两个词，您将开始对它在计算领域的作用有一个直觉。当服务器同时接收到大量请求时，它可能会减慢速度（吞吐量降低，延迟增加）。在一个点之后，它甚至可能失败（没有可用性）。  </p><p>您可以赋予服务器更多的力量（垂直缩放），也可以添加更多服务器（水平缩放）。但是现在您必须弄清楚收入请求如何分配到各个服务器-哪些请求被路由到哪些服务器以及如何确保它们也不会过载？换句话说，如何平衡和分配请求负载？</p><p>输入负载均衡器。由于本文是对原理和概念的介绍，因此它们在必要时必须经过非常简化的解释。负载平衡器的工作是坐在客户端和服务器之间（但可以在其他位置插入它），并研究如何在多个服务器之间分配传入请求负载，以便最终用户（客户端）的体验始终快速，流畅和可靠。</p><p>因此，负载均衡器就像是引导流量的流量管理器。他们这样做是为了保持<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#system-availability">可用性</a>和<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#storage-latency-throughput">吞吐量</a>。</p><p>了解负载均衡器在系统架构中的插入位置后，您会发现负载均衡器可以被视为<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#proxies">反向代理</a>。但是负载均衡器也可以插入其他位置，例如在其他交换机之间，例如在服务器和数据库之间。</p><h3 id="平衡法-服务器选择策略"><a href="#平衡法-服务器选择策略" class="headerlink" title="平衡法-服务器选择策略"></a>平衡法-服务器选择策略</h3><p>那么，负载均衡器如何决定如何路由和分配请求流量？首先，每次添加服务器时，都需要让负载均衡器知道它还有一个候选者可以将流量路由到该负载均衡器。  </p><p>如果卸下服务器，则负载均衡器也需要知道这一点。该配置可确保负载均衡器知道其转到列表中有多少台服务器以及哪些服务器可用。甚至可以使负载平衡器随时了解每台服务器的负载级别，状态，可用性，当前任务等。</p><p>将负载均衡器配置为知道可以重定向到哪些服务器后，我们需要制定最佳路由策略，以确保在可用服务器之间进行适当的分配。  </p><p>一个简单的方法是让负载均衡器随机选择一个服务器，然后以这种方式定向每个传入的请求。但是正如您可以想象的那样，随机性可能会导致问题和“不平衡”的分配，其中某些服务器的负载要比其他服务器更多，这可能会对整个系统的性能产生负面影响。</p><h3 id="循环赛和加权循环赛"><a href="#循环赛和加权循环赛" class="headerlink" title="循环赛和加权循环赛"></a>循环赛和加权循环赛</h3><p>可以直观理解的另一种方法称为“循环”。这是许多人处理列表循环的方式。您从列表中的第一项开始，依次向下移动，当最后一项完成后，您将循环回到顶部，然后再次开始处理列表。</p><p>负载均衡器也可以做到这一点，只需按固定顺序遍历可用服务器即可。这样，负载就以一种易于理解和可预测的模式在服务器上平均分配。  </p><p>通过将某些服务“加权”于其他服务，可以使轮询变得更“花哨”。在正常的标准轮询中，每个服务器的权重相等（假设所有服务器的权重均为1）。但是，当您对服务器加权时，可以使某些服务器的权重较低（例如，如果它们的功能较弱，则为0.5），而其他服务器的权重可能更高，例如0.7或0.9甚至是1。</p><p>然后，将根据这些权重按比例分配总流量，并相应地将其分配给功率与请求量成比例的服务器。</p><h3 id="基于负载的服务器选择"><a href="#基于负载的服务器选择" class="headerlink" title="基于负载的服务器选择"></a>基于负载的服务器选择</h3><p>更复杂的负载均衡器可以在其go-to列表中计算出服务器的当前容量，性能和负载，并根据当前负载和计算动态分配，从而获得最高吞吐量，最低延迟等。通过监视每个服务器的性能并确定哪些服务器可以和不能处理新请求。  </p><h3 id="基于IP哈希的选择"><a href="#基于IP哈希的选择" class="headerlink" title="基于IP哈希的选择"></a>基于IP哈希的选择</h3><p>您可以将负载均衡器配置为对传入请求的IP地址进行<a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Hashing/hashing.html">哈希</a>处理，并使用哈希值确定也由哪个服务器定向请求。如果我有5台服务器可用，则哈希函数将设计为返回五个哈希值之一，因此肯定会指定其中一台服务器来处理请求。</p><p>当您希望来自某个国家或地区的请求从最适合满足该地区内部需求的服务器获取数据时，或者在服务器缓存请求以便可以快速处理它们的情况下，基于IP哈希的路由可能非常有用。 。  </p><p>在后一种情况下，您要确保该请求发送到先前已缓存相同请求的服务器，因为这将提高处理和响应该请求的速度和性能。</p><p>如果每个服务器都维护独立的缓存，并且负载均衡器没有始终如一地向同一服务器发送相同的请求，则最终服务器将重新执行已经作为对另一个服务器的先前请求而完成的工作，并且您将失去优化能力与缓存数据一起使用。</p><h3 id="基于路径或服务的选择"><a href="#基于路径或服务的选择" class="headerlink" title="基于路径或服务的选择"></a>基于路径或服务的选择</h3><p>您还可以使负载均衡器根据请求的“路径”或所提供的功能或服务来路由请求。例如，如果您从在线花店购买鲜花，则可能会向一台服务器发送加载“特别花束”的请求，而向另一台服务器发送信用卡付款。</p><p>如果只有十分之一的访客实际购买了鲜花，那么您可以拥有一个较小的服务器来处理付款，而较大的服务器可以处理所有浏览流量。</p><h3 id="混合袋"><a href="#混合袋" class="headerlink" title="混合袋"></a>混合袋</h3><p>与所有事物一样，您可以达到更高和更详细的复杂程度。您可以有多个负载均衡器，每个负载均衡器都有不同的服务器选择策略！而且如果您的系统非常庞大且流量很高，那么您可能需要<em>负载均衡器作为负载均衡器…</em></p><p>最终，您需要向系统中添加组件，直到您的性能适应您的需求为止（您的需求可能看起来很平坦，或者随着时间的推移会缓慢上升，或者容易出现峰值！）。</p><h2 id="第7节：一致的哈希"><a href="#第7节：一致的哈希" class="headerlink" title="第7节：一致的哈希"></a>第7节：一致的哈希</h2><p>要理解的稍微棘手的概念之一是在负载平衡的上下文中进行哈希处理。因此它有自己的部分。</p><p>为了理解这一点，请首先了解<a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Hashing/hashing.html">哈希在概念上是如何工作的</a>。TL; DR是哈希将输入转换为固定大小的值，通常是整数值（哈希）。  </p><p>好的哈希算法或函数的关键原则之一是函数必须是<a href="https://en.wikipedia.org/wiki/Hash_function#Deterministic">确定性的</a>，这是一种很好的说法，可以说相同的输入传递给函数时将生成相同的输出。因此，确定性的意思是-如果我传入字符串“ Code”（区分大小写）并且该函数生成哈希值11002，则每次我传入“ Code”时，它都必须生成“ 11002”作为整数。如果我输入“代码”，它将生成一个不同的数字（一致）。</p><p>有时，散列函数可以为多个输入生成相同的散列-这不是世界末日，并且有多种处理方法。实际上，唯一输入范围越多，可能性就越大。但是，当一个以上的输入确定性地生成相同的输出时，则称为“冲突”。</p><p>牢记这一点，让我们将其应用于路由和定向到服务器的请求。假设您有5台服务器来分配负载。一种易于理解的方法是对传入的请求进行哈希处理（可能按IP地址或某些客户端详细信息），然后为每个请求生成哈希。然后，将模运算符应用于该哈希，其中正确的操作数是服务器的数量。  </p><p>例如，这就是您的负载均衡器的伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">request#<span class="number">1</span> =&gt; hashes to <span class="number">34</span></span><br><span class="line">request#<span class="number">2</span> =&gt; hashes to <span class="number">23</span></span><br><span class="line">request#<span class="number">3</span> =&gt; hashes to <span class="number">30</span></span><br><span class="line">request#<span class="number">4</span> =&gt; hashes to <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You have 5 servers =&gt; [Server A, Server B ,Server C ,Server D ,Server E]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// so modulo 5 for each request...</span></span><br><span class="line"></span><br><span class="line">request#<span class="number">1</span> =&gt; hashes to <span class="number">34</span> =&gt; <span class="number">34</span> % <span class="number">5</span> = <span class="number">4</span> =&gt; send <span class="built_in">this</span> request to servers[<span class="number">4</span>] =&gt; Server E</span><br><span class="line"></span><br><span class="line">request#<span class="number">2</span> =&gt; hashes to <span class="number">23</span> =&gt; <span class="number">23</span> % <span class="number">5</span> = <span class="number">3</span> =&gt; send <span class="built_in">this</span> request to servers[<span class="number">3</span>] =&gt; Server D</span><br><span class="line"></span><br><span class="line">request#<span class="number">3</span> =&gt; hashes to <span class="number">30</span> =&gt; <span class="number">30</span> % <span class="number">5</span> = <span class="number">0</span> =&gt; send <span class="built_in">this</span> request to  servers[<span class="number">0</span>] =&gt; Server A</span><br><span class="line"></span><br><span class="line">request#<span class="number">4</span> =&gt; hashes to <span class="number">14</span> =&gt; <span class="number">14</span> % <span class="number">5</span> = <span class="number">4</span> =&gt; send <span class="built_in">this</span> request to servers[<span class="number">4</span>] =&gt; Server E</span><br></pre></td></tr></table></figure><p>如您所见，散列函数生成可能值的散布，并且当应用模运算符时，它将带出映射到服务器编号的较小范围的编号。</p><p>您肯定会获得映射到同一台服务器的不同请求，这很好，只要对所有服务器的总体分配具有“<a href="https://en.wikipedia.org/wiki/Hash_function#Uniformity">统一性</a>”即可。</p><h3 id="添加服务器和处理故障服务器"><a href="#添加服务器和处理故障服务器" class="headerlink" title="添加服务器和处理故障服务器"></a>添加服务器和处理故障服务器</h3><p>那么-如果我们要向其发送流量的服务器之一死了怎么办？哈希函数（请参阅上面的伪代码段）仍然认为有5台服务器，并且mod运算符生成的范围是0-4。但是，由于其中一台发生了故障，我们现在只有4台服务器，并且仍在向其发送流量。哎呀。</p><p>相反，我们可以添加第六台服务器，但是由于我们的mod运算符为5，因此永远<em>不会</em>获得任何流量，并且永远不会产生包含新添加的第六台服务器的数字。糟糕！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Let&#x27;s add a 6th server</span><br><span class="line">servers =&gt; [Server A, Server B ,Server C ,Server D ,Server E, Server F]</span><br><span class="line"></span><br><span class="line">// let&#x27;s change the modulo operand to 6</span><br><span class="line">request#1 =&gt; hashes to 34 =&gt; 34 % 6 = 4 =&gt; send this request to servers[4] =&gt; Server E</span><br><span class="line"></span><br><span class="line">request#2 =&gt; hashes to 23 =&gt; 23 % 6 = 5 =&gt; send this request to servers[5] =&gt; Server F</span><br><span class="line"></span><br><span class="line">request#3 =&gt; hashes to 30 =&gt; 30 % 6 = 0 =&gt; send this request to  servers[0] =&gt; Server A</span><br><span class="line"></span><br><span class="line">request#4 =&gt; hashes to 14 =&gt; 14 % 6 = 2 =&gt; send this request to servers[2] =&gt; Server C</span><br></pre></td></tr></table></figure><p>我们注意到应用mod后的服务器号发生了变化（尽管在此示例中，请求号1和请求号3<em>均不</em>更改-但这仅是因为在这种特定情况下，该号才有效）。</p><p>实际上，结果是一半的请求（在其他示例中可能会更多！）现在全部路由到新服务器，并且我们失去了以前在服务器上缓存的数据的好处。  </p><p>例如，请求＃4曾经去到服务器E，但现在去了服务器C。与请求＃4坐在服务器E上有关的所有缓存数据都没有用，因为请求现在要去服务器C。您可以计算对于其中一台服务器死亡的地方，也存在类似的问题，但是mod函数不断向其发送请求。</p><p>在这个很小的系统中，声音听起来很小。但是在非常大规模的系统中，这是一个很差的结果。#SystemDesignFail。</p><p>显然，简单的哈希分配系统无法很好地扩展或处理故障。</p><h3 id="流行的解决方案-一致性哈希"><a href="#流行的解决方案-一致性哈希" class="headerlink" title="流行的解决方案-一致性哈希"></a>流行的解决方案-一致性哈希</h3><p>不幸的是，这是我觉得单词描述不够的部分。最好从视觉上理解一致性哈希。但是到目前为止，本文的目的是让您对问题有一个直观的认识，它是什么，它为什么会出现，以及基本解决方案中的缺点是什么。请牢记这一点。</p><p>正如我们所讨论的，朴素散列的关键问题在于，当（A）服务器发生故障时，流量仍会路由到该服务器，并且（B）添加新服务器时，分配可能会发生实质性变化，从而失去了以前的缓存。</p><p>深入研究一致的哈希时，需要牢记两个非常重要的事情：</p><ol><li>一致的哈希<em>不能消除问题</em>，尤其是B。但是它确实可以大大减少问题。刚开始时，您可能会想知道，一致性哈希有什么大不了，因为潜在的缺点仍然存在-是的，但程度要小得多，这本身对于大型系统来说是一项有价值的改进。</li><li>一致的哈希将哈希函数应用于传入的请求<em>和服务器</em>。因此，最终的输出落入值的设定范围（连续）。这个细节非常重要。</li></ol><p>在观看以下推荐的视频时，请牢记这些内容，这些视频说明了哈希的一致性，否则，其好处可能并不明显。</p><p>我强烈推荐该视频，因为它嵌入了这些原则，而又不会给您带来太多细节。</p><iframe width="480" height="270" src="https://www.youtube.com/embed/tHEyzVbl4bg?start=370&amp;feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" style="box-sizing: inherit; margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; line-height: inherit; font-family: inherit; font-size: 22px; vertical-align: middle;"></iframe>汉娜·巴顿（Hannah Barton）简介<p>如果您在真正理解此策略为何对负载均衡很重要时遇到一些麻烦，建议您稍作休息，然后返回<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#load-balancing">负载均衡部分</a>，然后再次阅读此内容。除非您在工作中直接遇到问题，否则所有这些都会变得非常抽象，这并不罕见！</p><h2 id="第8节：数据库"><a href="#第8节：数据库" class="headerlink" title="第8节：数据库"></a>第8节：数据库</h2><p>我们简要地<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#storage-latency-throughput">考虑</a>了为满足许多不同用例而设计的不同类型的存储解决方案（数据库），并且其中一些更适合于某些任务。但是，从很高的层次上讲，数据库可以分为两种类型：关系型和非关系型。  </p><h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>一个<strong>关系数据库</strong>是一个已严格执行存储在数据库中的东西之间的关系。通常，通过要求数据库将每个此类事物（称为“实体”）表示为结构化表-具有零或多个行（“记录”，“条目”）和一个或多个列（“属性”），使这些关系成为可能。 ，“字段”）。</p><p>通过在实体上强制采用这种结构，我们可以确保每个项目/条目/记录都有正确的数据。它使实体之间具有更好的一致性和紧密关系的能力。  </p><p>您可以在下表中记录“婴儿”（实体）数据的表格中看到此结构。表中的每个记录（“条目”）都有4个字段，代表与该婴儿有关的数据。这是经典的关系数据库结构（形式化的实体结构称为<a href="https://en.wikipedia.org/wiki/Database_schema">模式</a>）。</p><p><img src="https://www.freecodecamp.org/news/content/images/2020/03/image-46.png" alt="img">来源：<a href="https://web.stanford.edu/class/cs101/table-1-data.html">https</a> : <a href="https://web.stanford.edu/class/cs101/table-1-data.html">//web.stanford.edu/class/cs101/table-1-data.html</a></p><p>因此，了解关系数据库的关键特征是它们是高度结构化的，并且将结构强加给所有实体。通过确保添加到表的数据符合该结构来实施此结构。在其架构不允许的情况下，无法在表格中添加高度字段。</p><p>大多数关系数据库都支持一种称为SQL<a href="https://en.wikipedia.org/wiki/SQL">结构化查询语言</a>的数据库查询<a href="https://en.wikipedia.org/wiki/SQL">语言</a>。这是一种专门设计用于与结构化（关系）数据库的内容进行交互的语言。这两个概念紧密地结合在一起，以至于人们经常将关系数据库称为“ SQL数据库”（有时也称为“续集”数据库）。  </p><p>通常，人们认为SQL（关系）数据库比非关系数据库支持更复杂的查询（组合不同的字段，过滤器和条件）。数据库本身会处理这些查询并发送回匹配的结果。  </p><p>许多喜欢SQL数据库的人认为，如果没有该功能，则必须获取<em>所有</em>数据，然后让服务器或客户端将数据“<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#storage-latency-throughput">存储</a>”<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#storage-latency-throughput">在内存中，</a>并应用过滤条件-对于少量数据集，这是可以的但是对于具有数百万条记录和行的大型，复杂的数据集而言，这将严重影响性能。但是，情况并非总是如此，当我们了解NoSQL数据库时就会看到。</p><p>关系数据库的一个常见且广受欢迎的示例是<a href="https://en.wikipedia.org/wiki/PostgreSQL">PostgreSQL</a>（通常称为“ Postgres”）数据库。  </p><h3 id="酸"><a href="#酸" class="headerlink" title="酸"></a>酸</h3><p>ACID事务是描述良好关系数据库将支持的事务的一组功能。<a href="https://en.wikipedia.org/wiki/ACID">ACID =“原子，一致，隔离，耐用”</a>。事务是与数据库的交互，通常是读或写操作。</p><p><strong>原子性</strong>要求当一个事务包含多个操作时，数据库必须保证如果一个操作失败，则<em>整个</em>事务（所有操作）也会失败。它是“全有或全无”。这样，如果事务成功，则完成后您将知道所有子操作均已成功完成，并且如果操作失败，则您将知道随之进行的所有操作都将失败。  </p><p>例如，如果单个事务涉及读取两个表并写入三个表，那么如果这些单个操作中的任何一个失败，则整个事务都会失败。这意味着这些单独的操作都不应该完成。您甚至不希望3个写入事务中的1个起作用—这会“弄脏”数据库中的数据！</p><p><strong>一致性</strong>要求根据数据库中定义的规则，数据库中的每个事务都是有效的，并且当数据库更改状态（某些信息已更改）时，这种更改是有效的，并且不会破坏数据。每个事务将数据库从一个<em>有效</em>状态移动到另一<em>有效</em>状态。一致性可以认为如下：每个“读取”操作都会收到最新的“写入”操作结果。</p><p><strong>隔离</strong>意味着您可以“同时”（同时）在数据库上运行多个事务，但是数据库最终将处于一种状态，看起来每个操作都已按顺序进行（按顺序执行，如操作队列） ）。我个人认为“隔离”不是这个概念的描述性术语，但是我猜想ACCD比ACID难说…</p><p><strong>持久性</strong>是保证一旦将数据存储在数据库中，它将保持不变。它将是“<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#section-2-storage-latency-throughput">持久的</a>”-存储在磁盘上而不是“内存”中。  </p><h3 id="非关系数据库"><a href="#非关系数据库" class="headerlink" title="非关系数据库"></a>非关系数据库</h3><p>相反，<strong>非关系数据库</strong>对其数据的刚性较差，或者换句话说，结构较灵活。数据通常显示为“键值”对。一种简单的表示方式是将其作为“键-值”对对象的数组（列表），例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// baby names</span></span><br><span class="line">[</span><br><span class="line">&#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jacob&quot;</span>,</span><br><span class="line">        <span class="attr">rank</span>: ##,</span><br><span class="line">        <span class="attr">gender</span>: <span class="string">&quot;M&quot;</span>,</span><br><span class="line">        <span class="attr">year</span>: ####</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Isabella&quot;</span>,</span><br><span class="line">        <span class="attr">rank</span>: ##,</span><br><span class="line">        <span class="attr">gender</span>: <span class="string">&quot;F&quot;</span>,</span><br><span class="line">        <span class="attr">year</span>: ####</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>非关系数据库也称为“ NoSQL”数据库，当您不希望或不需要具有一致的结构化数据时，它们将为您带来好处。</p><p>与ACID属性类似，NoSQL数据库属性有时也称为BASE：</p><p><strong>基本可用</strong>，表示系统保证可用性</p><p><strong>软状态</strong>均值意味着即使没有输入，系统状态也可能随时间变化</p><p><strong>最终一致性</strong>指出，除非收到其他输入，否则系统将在（非常短的）时间内保持一致。</p><p>由于这些数据库的核心是将数据保存在类似于散列表的结构中，因此它们非常快速，简单且易于使用，非常适合诸如缓存，环境变量，配置文件和会话状态等用例。灵活性使它们非常适合在内存（例如<a href="https://en.wikipedia.org/wiki/Memcached">Memcached</a>）和持久性存储（例如<a href="https://en.wikipedia.org/wiki/Amazon_DynamoDB">DynamoDb</a>）中使用。</p><p>还有其他称为文档数据库的“类似于JSON”的数据库，例如广受欢迎的<a href="https://www.mongodb.com/document-databases">MongoDb</a>，它们的核心也是“键值”存储。</p><h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>这是一个复杂的主题，因此，我将简要介绍一下表面知识，以便为您提供有关系统设计面试需要的高级概述。</p><p>想象一个拥有1亿行的数据库表。该表主要用于在每个记录中查找一个或两个值。要检索特定行的值，您需要遍历表。如果这是最后一条记录，那将需要很长时间！</p><p>索引是一种捷径记录的方式，该记录具有匹配值，比遍历每一行更有效。索引通常是添加到数据库中的数据结构，旨在促进快速搜索数据库中的那些<em>特定</em>属性（字段）。</p><p>因此，如果人口普查局有1.2亿条具有名称和年龄的记录，并且您最经常需要检索属于某个年龄组的人员列表，则可以在“年龄”属性上对该数据库建立索引。</p><p>索引是关系数据库的核心，并且在非关系数据库上也广泛提供索引。因此，从理论上讲，索引的好处可用于两种类型的数据库，这对于优化查找时间非常有利。</p><h3 id="复制和分片"><a href="#复制和分片" class="headerlink" title="复制和分片"></a>复制和分片</h3><p>虽然这些听起来像是一部生物恐怖电影中的东西，但您更可能每天在数据库扩展的背景下听到它们。</p><p>复制是指复制（复制，复制）数据库。您可能还记得我们讨论<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#system-availability">可用性</a>时的<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#system-availability">情况</a>。</p><p>我们已经考虑了在系统中具有冗余以维持高可用性的好处。如果一个数据库出现故障，复制可确保数据库中的冗余。但这也引发了一个问题，即如何在副本之间同步数据，因为它们具有相同的数据。对数据库的写入和更新操作的复制可以同步（与更改主数据库同时）或异步进行。  </p><p>同步主数据库和副本数据库之间可接受的时间间隔实际上取决于您的需求-如果您确实需要两个数据库之间的状态保持一致，则复制需要快速进行。您还希望确保，如果对副本的写操作失败，那么对主数据库的写操作也会失败（原子性）。</p><p>但是，当您拥有如此多的数据以至于仅仅对其进行复制可能会解决可用性问题，但不能解决吞吐量和延迟问题（速度）时，您该怎么办？  </p><p>此时，您可能需要考虑将数据“分块”为“碎片”。有人也称此为分区数据（与分区硬盘不同！）。  </p><p>分片数据会将您的大型数据库分解为较小的数据库。您可以根据数据的结构来确定如何分片数据。就像将每500万行存储在一个不同的分片中一样简单，或者采用其他最适合您的数据，需求和所服务位置的策略。</p><h2 id="第9节：领导人选举"><a href="#第9节：领导人选举" class="headerlink" title="第9节：领导人选举"></a>第9节：领导人选举</h2><p>让我们再次回到服务器以讨论一个稍微高级的主题。我们已经了解了<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#section-3-system-availability">可用性</a>的原理，以及冗余是提高可用性的一种方式。在处理将<a href="https://www.freecodecamp.org/news/systems-design-for-interviews/#section-6-load-balancing">请求路由</a>到冗余服务器群集时，我们还介绍了一些实际的注意事项。</p><p>但是有时，在这种设置中，多台服务器要做的事情差不多，可能会出现只需要一台服务器带头的情况。</p><p>例如，您要确保仅赋予一台服务器负责更新某些第三方API的责任，因为来自不同服务器的多次更新可能会导致问题或增加第三方方面的成本。  </p><p>在这种情况下，您需要选择该主服务器来将此更新职责委派给该主服务器。这个过程称为<a href="https://en.wikipedia.org/wiki/Leader_election">领导人选举</a>。  </p><p>当群集中有多个服务器以提供冗余时，它们之间可以配置为只有一个领导者。他们还将检测该领导服务器何时发生故障，并指定另一台服务器代替它。</p><p>原理很简单，但细节在于魔鬼。真正棘手的部分是确保服务器在数据，状态和操作方面“同步”。</p><p>例如，始终存在某些中断可能导致一台或两台服务器与其他服务器断开连接的风险。在这种情况下，工程师最终会使用一些在区块链中使用的基础思想来为服务器集群导出共识值。  </p><p>换句话说，使用<a href="https://en.wikipedia.org/wiki/Consensus_algorithm">共识算法</a>为所有服务器提供一个“商定”值，当确定哪个服务器是领导者时，它们可以全部依靠其逻辑。</p><p>领导者选举通常使用诸如<a href="https://etcd.io/">etcd之类的</a>软件来实现，该软件是一个键值对存储，通过使用领导者选举本身并使用共识算法，可以提供高可用性<em>和</em>强一致性（这是有价值的和不寻常的组合）。  </p><p>因此，工程师可以依靠etcd自己的领导者选举架构在系统中进行领导者选举。这是通过在代表etcd的服务中存储代表当前领导者的键值对来完成的。  </p><p>由于ETCD高度可用<em>和</em>强烈一致的，即键-值对总是可以通过你的系统依赖于包含集群最后的“真理之源”的服务器是当前选出的领导人。</p><h2 id="第10节：轮询，流式传输，套接字"><a href="#第10节：轮询，流式传输，套接字" class="headerlink" title="第10节：轮询，流式传输，套接字"></a>第10节：轮询，流式传输，套接字</h2><p>在持续更新，推送通知，流内容和实时数据的现代时代，重要的是要掌握支撑这些技术的基本原理。要定期或立即更新应用程序中的数据，需要使用以下两种方法之一。</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>这很简单。如果您查看<a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">维基百科条目</a>，可能会发现它有点紧张。因此，请查看其词典含义，尤其是在计算机科学的上下文中。牢记这个简单的基础。</p><p><img src="https://www.freecodecamp.org/news/content/images/2020/03/Screen-Shot-2020-03-14-at-10.25.44-am.png" alt="img"></p><p>轮询只是让您的客户端“检查”向您的服务器发送网络请求并请求更新的数据。这些请求通常按固定的时间间隔发出，例如5秒，15秒，1分钟或您的用例需要的任何其他时间间隔。</p><p>每几秒钟轮询一次仍然与实时轮询不太一样，并且还存在以下缺点，特别是如果您同时拥有一百万以上的用户：</p><ul><li>几乎恒定的网络请求（不适用于客户端）</li><li>几乎恒定的入站请求（对于服务器负载而言不大-每秒超过100万个请求！）</li></ul><p>因此，快速轮询并不是真正有效或高效的方法，因此，在数据更新中的细小间隙对您的应用程序来说不是问题的情况下，最好使用轮询。</p><p>例如，如果您构建了一个Uber克隆，则可能让驾驶员端应用程序每5秒发送一次驾驶员位置数据，并且让驾驶员方应用程序每5秒轮询一次驾驶员的位置。</p><h3 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h3><p>流式传输解决了不断轮询的问题。如果有必要不断命中服务器，那么最好使用称为<a href="https://en.wikipedia.org/wiki/WebSocket">web-sockets的</a>东西。</p><p>这是一种旨在通过TCP工作的网络通信协议。它在客户端和服务器之间打开双向专用通道（套接字），有点像两个端点之间的开放热线。</p><p>与通常的TCP / IP通信不同，这些套接字是“长期存在的”，因此它向服务器发出的单个请求打开了此热线以进行双向数据传输，而不是多个单独的请求。长期而言，我们的意思是机器之间的套接字连接将持续到双方将其关闭或网络断开为止。</p><p>您可能还记得我们在IP，TCP和HTTP上的讨论，它们通过为每个请求-响应周期发送数据“数据包”来进行操作。Web套接字意味着只有一个请求-响应交互（如果您考虑的话，实际上不是一个循环！），这打开了以“流”形式发送两个数据的通道。</p><p>轮询和所有基于“常规” IP的通信的最大区别在于，尽管轮询使客户端以固定的时间间隔向服务器请求数据（“拉动”数据），但在流传输中，客户端处于“待命”状态，等待服务器以其方式“推送”一些数据。服务器将在数据更改时发送数据，客户端始终在监听数据。因此，如果数据变化是恒定的，则它将变成“流”，这可能会更好地满足用户的需求。  </p><p>例如，在使用<a href="https://www.freecodecamp.org/news/p/51a1d601-c57e-48cf-8f8d-9bb1c333d64d/repl.it">协作编码IDE时</a>，当两个用户中的任何一个键入内容时，它都可以显示在另一个上，并且这是通过网络套接字完成的，因为您希望进行实时协作。如果在您尝试键入相同的内容后或等待3分钟之后才想知道我在做什么，那么我输入的内容会显示在屏幕上会很糟！</p><p>或想到在线多人游戏-这是在玩家之间流式传输游戏数据的完美用例！</p><p>总之，用例确定了轮询和流式传输之间的选择。通常，如果您的数据是“实时”的，则希望流式传输，并且如果可以有滞后时间（即使只有15秒仍是滞后时间），那么轮询可能是一个不错的选择。但这全取决于您有多少同时用户以及他们是否希望数据是即时的。流服务的一个常用示例是<a href="https://en.wikipedia.org/wiki/Apache_Kafka">Apache Kafka</a>。</p><h2 id="第11节：端点保护"><a href="#第11节：端点保护" class="headerlink" title="第11节：端点保护"></a>第11节：端点保护</h2><p>当您构建大型系统时，保护系统免受过多的操作（使用系统实际上不需要进行此类操作）变得很重要。现在听起来很抽象。但是，请考虑一下-您几次疯狂地单击按钮，认为它将使系统响应速度更快？想象一下，如果这些按钮中的每个按钮都单击ping服务器，而该服务器试图全部处理它们！如果由于某种原因（例如服务器在异常负载下挣扎），系统的吞吐量较低，那么每次单击都会使系统变得更慢，因为它必须处理所有这些！</p><p>有时甚至与保护系统无关。有时您想限制操作，因为这是服务的一部分。例如，您可能在第三方API服务上使用了免费套餐，其中每30分钟间隔仅允许您发出20个请求。如果您在30分钟的间隔内发出21或300个请求，则在前20个之后，该服务器将停止处理您的请求。</p><p>这就是所谓的限速。使用速率限制，服务器可以在给定的时间范围内限制客户端尝试的操作次数。可以根据用户，请求，时间，有效负载或其他事物来计算速率限制。通常，一旦在时间窗口中超过了限制，则对于该窗口的其余时间，服务器将返回错误。</p><p>好的，现在您可能会认为端点“保护”是一种夸张。您只是在限制用户从端点获取某些东西的能力。的确如此，但是当用户（客户端）是恶意的时（例如说是破坏您的端点的机器人），它也是一种保护。为什么会这样？因为向服务器泛滥的请求超出其处理能力，这是恶意人员用来关闭该服务器的策略，从而有效地关闭了该服务。这正是<a href="https://en.wikipedia.org/wiki/Denial-of-service_attack">拒绝服务（D0S）攻击的本质</a>。</p><p>尽管可以通过这种方式防御DoS攻击，但速率限制本身并不能保护您免受DoS攻击的复杂版本-<em>分布式</em>DoS的攻击。这里的分布只是意味着攻击来自看似无关的多个客户端，并且没有真正的方法将其识别为受单个恶意代理控制。需要使用其他方法来防止这种协调的分布式攻击。</p><p>但是无论如何，对于不太可怕的用例，速率限制都是有用且流行的，例如我提到的API限制。考虑到速率限制的工作原理，由于服务器必须首先检查限制条件并在必要时强制执行限制条件，因此您需要考虑要使用哪种数据结构和数据库来使这些检查超快，以便如果请求在允许的范围内，则不会减慢处理请求的速度。另外，如果您将其存储在服务器本身的内存中，则需要保证来自给定客户端的所有请求都将到达该服务器，以便它可以正确实施限制。要处理这种情况，通常使用单独的<a href="https://en.wikipedia.org/wiki/Redis">Redis服务</a> 位于服务器外部，但将用户的详细信息保留在内存中，并且可以快速确定用户是否在允许的范围内。</p><p>速率限制可以和您要执行的规则一样复杂，但是上一节应涵盖基本知识和最常见的用例。</p><h2 id="第12节：消息和发布订阅"><a href="#第12节：消息和发布订阅" class="headerlink" title="第12节：消息和发布订阅"></a>第12节：消息和发布订阅</h2><p>当您设计和构建大型<a href="https://blog.stackpath.com/distributed-system/">分布式系统时</a>，要使该系统凝聚而流畅地工作，就必须在组成系统的组件和服务之间交换信息。但是，正如我们之前所看到的那样，依赖网络的系统与网络具有同样的弱点-它们非常脆弱。网络发生故障，这种情况很少发生。当网络出现故障时，系统中的组件无法通信可能会降低系统性能（最佳情况）或导致系统完全故障（最坏情况）。因此，即使系统中组件之间存在“任意分区”（即故障），分布式系统也需要可靠的机制来确保通信在中断处继续进行或恢复。</p><p>举例来说，假设您正在预订机票。您将获得一个不错的价格，选择您的座位，确认预订，甚至还使用信用卡付款。现在，您正在等待票证PDF到达收件箱。您等待，再等待，它永远不会到来。在某个地方，发生了无法处理或无法正确恢复的系统故障。预订系统通常会与航空公司和定价API连接，以处理实际的航班选择，票价摘要，航班日期和时间等。所有这些操作都是在您单击网站的预订UI时完成的。但是，几分钟后，它不必将票证的PDF发送给您。取而代之的是，UI可以简单地确认您的预订已完成，并且您可以很快在收件箱中找到门票。那’ 这是一种合理且通用的预订用户体验，因为付款的时刻和票证的接收不必同时进行-这两个事件可以是异步的。这样的系统需要进行消息传递以确保异步生成PDF的服务（服务器端点）收到已确认的付费预订以及所有详细信息的通知，然后可以自动生成PDF并通过电子邮件发送给您。但是，如果该消息传递系统发生故障，则电子邮件服务将永远不会知道您的预订，并且不会生成任何票证。和所有详细信息，然后可以自动生成PDF并通过电子邮件发送给您。但是，如果该消息传递系统发生故障，则电子邮件服务将永远不会知道您的预订，并且不会生成任何票证。和所有详细信息，然后可以自动生成PDF并通过电子邮件发送给您。但是，如果该消息传递系统发生故障，则电子邮件服务将永远不会知道您的预订，并且不会生成任何票证。</p><p><strong>发布者/订阅者消息</strong></p><p>这是一个非常流行的消息传递范例（模型）。关键概念是发布者“发布”消息，而订阅者订阅消息。为了提供更大的粒度，消息可以属于某个“主题”，就像一个类别。这些主题就像专用的“渠道”或管道，其中每个管道互斥处理属于特定主题的消息。订阅者选择他们想要订阅的主题，并获得该主题中消息的通知。该系统的优势在于，发布者和订阅者可以完全分离，即他们不需要彼此了解。发布者宣布，订阅者收听其正在寻找的主题的通告。</p><p>服务器通常是消息的发布者，通常有多个主题（渠道）被发布到。特定主题的使用者订阅了这些主题。服务器（发布者）和订户（可以是另一台服务器）之间没有直接通信。唯一的交互作用是发布者和主题之间以及主题和订阅者之间。</p><p>主题中的消息只是需要传达的数据，并且可以采用您需要的任何形式。这样一来，您可以在发布/订阅中获得四个角色：发布者，订阅者，主题和消息。</p><h3 id="比数据库更好"><a href="#比数据库更好" class="headerlink" title="比数据库更好"></a>比数据库更好</h3><p>那么，为什么要为此烦恼呢？为什么不将所有数据持久保存到数据库并直接从那里使用呢？嗯，您需要一个系统来使消息排队，因为每个消息都对应于一个需要根据该消息的数据完成的任务。因此，在我们的票务示例中，如果100个人在35分钟内完成预订，那么将所有内容都放入数据库中并不能解决通过电子邮件发送这100个人的问题。它只存储100个事务。发布/订阅系统处理通信，任务排序<em>和</em>消息将保留在数据库中。因此，系统可以提供有用的功能，例如“至少一次”传递（消息不会丢失），持久存储，消息排序，消息“重试”，“可重播”等。如果没有此系统，仅将消息存储在数据库中将无法帮助您确保消息已传递（使用）并已采取行动成功完成任务。  </p><p>有时，同一条消息可能会被订户消耗一次以上-通常是由于网络暂时中断，尽管订户消耗了该消息，但并没有让发布者知道。因此，发布者只需将其重新发送给订阅者即可。这就是为什么保证是“至少一次”而不是“一次且只有一次”的原因。在分布式系统中，这是不可避免的，因为网络本质上是不可靠的。这可能会带来复杂性，其中消息会在订户侧触发操作，并且该操作可能会更改数据库中的内容（更改整个应用程序中的状态）。如果单个操作被重复多次，并且应用程序的状态每次更改都会怎样？</p><h3 id="控制结果-一个或多个结果？"><a href="#控制结果-一个或多个结果？" class="headerlink" title="控制结果-一个或多个结果？"></a>控制结果-一个或多个结果？</h3><p>解决这个新问题的方法称为幂等性（幂等性），这是一个很重要的概念，但在前几次检查时并不直观。这个概念可能看起来很复杂（特别是如果您阅读了Wikipedia条目），因此出于当前目的，这是<a href="https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation">StackOverflow的</a>一种用户友好的简化形式：</p><blockquote><p><em>在计算中，幂等运算是指如果使用相同的输入参数多次调用幂等运算，则不会产生任何其他影响。</em></p></blockquote><p>因此，当订户处理一条消息两次或三遍时，应用程序的总体状态恰好是<em>第</em>一次处理该消息后的状态。例如，如果在预订机票结束时并且输入了信用卡详细信息之后，由于系统运行缓慢，您单击了“立即付款”三次，则您不想支付3倍的机票价格。 ？您需要具有幂等性，以确保<em>第</em>一次点击后的每次点击都不会再次进行购买，并且会多次向您的信用卡收费。相反，您可以在最好的朋友的新闻提要上发表相同评论N次。它们都将显示为单独的注释，除了令人讨厌之外，这实际上不是<em>错误的。</em>另一个示例是在“中”帖子上提供“拍手”-每个拍手都是为了增加拍手的数量，而不是一个，只能一个。后两个示例不需要幂等，但付款示例需要。</p><p>消息传递系统有许多种风格，系统的选择取决于要解决的用例。人们经常会提到“基于事件”的体系结构，这意味着系统依赖于有关“事件”的消息（例如为票证付款）来处理操作（例如通过电子邮件发送票证）。真正经常谈论的服务是Apache Kafka，RabbitMQ，Google Cloud Pub / Sub，AWS SNS / SQS。</p><h2 id="第13节：较小的必需品"><a href="#第13节：较小的必需品" class="headerlink" title="第13节：较小的必需品"></a>第13节：较小的必需品</h2><h3 id="记录中"><a href="#记录中" class="headerlink" title="记录中"></a>记录中</h3><p>随着时间的流逝，您的系统将收集大量数据。这些数据大部分非常有用。它可以使您了解系统的运行状况，性能和问题。它还可以为您提供有价值的见解，以了解谁使用您的系统，他们如何使用它，多久使用一次，或多或少使用哪些部分等等。  </p><p>这些数据对于分析，性能优化和产品改进非常有价值。这对于调试非常有价值，不仅在开发过程中登录到控制台时，而且在寻找测试和生产环境中的错误时，都非常有用。因此，日志也有助于跟踪和审核。  </p><p>记录日志时要记住的关键技巧是将其视为一系列连续事件，这意味着数据成为时间序列数据，并且应特别设计使用的工具和数据库来帮助处理此类数据。</p><h3 id="监控方式"><a href="#监控方式" class="headerlink" title="监控方式"></a>监控方式</h3><p>这是登录后的下一步。它回答了“如何处理所有记录数据？”的问题。您监视并分析它。您构建或使用工具和服务来解析这些数据，并为您提供仪表板或图表或以其他人类可读的方式理解这些数据的方法。</p><p>通过将数据存储在专门用于处理此类数据（时间序列数据）的数据库中，您可以插入基于该数据结构和意图构建的其他工具。</p><h3 id="警示"><a href="#警示" class="headerlink" title="警示"></a>警示</h3><p>当您积极监视时，还应该放置一个系统，以提醒您发生重大事件。就像对股票价格超过某个上限或低于某个阈值发出警报一样，如果您正在观察的某些指标过高或过低，则可能会发送警报。如果响应时间（延迟）或错误和失败超过“可接受的”水平，则可以设置警报。</p><p>良好的日志记录和监视的关键是确保您的数据在一段时间内相当一致，因为使用不一致的数据可能会导致缺少字段，从而破坏分析工具或降低日志记录的好处。</p><h2 id="资源资源"><a href="#资源资源" class="headerlink" title="资源资源"></a>资源资源</h2><p>如所承诺的，一些有用的资源如下：</p><ol><li>精彩的<a href="https://github.com/donnemartin/system-design-primer">Github回购</a>，其中包含概念，图表和学习准备</li><li>Tushar Roy对<a href="https://www.youtube.com/watch?v=UzLMhqg3_Wc">系统设计</a>的介绍</li><li>Gaurav Sen的<a href="https://www.youtube.com/watch?v=quLrc3PbuIw&list=PLMCXHnjXnTnvo6alSjVkgxV-VH6EPyvoX">YouTube播放列表</a></li><li><a href="https://www.sitepoint.com/sql-vs-nosql-differences/">SQL与NoSQL</a></li></ol><p>希望您喜欢这份长篇指南！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;系统设计面试问题–您应该知道的概念（转载）&quot;&gt;&lt;a href=&quot;#系统设计面试问题–您应该知道的概念（转载）&quot; class=&quot;headerlink&quot; title=&quot;系统设计面试问题–您应该知道的概念（转载）&quot;&gt;&lt;/a&gt;系统设计面试问题–您应该知道的概念（转载）&lt;/</summary>
      
    
    
    
    
    <category term="系统设计" scheme="https://groupfusion.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Host &#39;192.168.＊.＊&#39; is not allowed to connect to this MariaDB server</title>
    <link href="https://groupfusion.github.io/2017/06/23/db/mysql%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/"/>
    <id>https://groupfusion.github.io/2017/06/23/db/mysql%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/</id>
    <published>2017-06-23T01:47:57.000Z</published>
    <updated>2023-12-15T12:50:18.191Z</updated>
    
    <content type="html"><![CDATA[<p>＃报错:”Host ‘192.168.＊.＊’ is not allowed to connect to this MariaDB server”</p><p>两种解决方法：</p><ol><li>改表法。</li></ol><p>可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”, 使得可以在远程访问到mysql。</p><p>mysql -u root -pvmwaremysql&gt;use mysql;</p><p>mysql&gt;update user set host = ‘%’ where user = ‘root’;</p><p>mysql&gt;select host, user from user;</p><p>mysql&gt;FLUSH RIVILEGES</p><span id="more"></span><ol start="2"><li>授权法。</li></ol><p>例如，你想myuser使用mypassword从 <code>任何主机</code> 连接到mysql服务器的话。</p><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘myuser‘@’%’ IDENTIFIED BY ‘mypassword’ WITH GRANT OPTION;</p><p>FLUSH   PRIVILEGES;</p><p>如果你想允许用户myuser从ip为<code>192.168.1.3</code>的主机连接到mysql服务器，并使用mypassword作为密码</p><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘myuser‘@’192.168.1.3’ IDENTIFIED BY ‘mypassword’ WITH GRANT OPTION;</p><p>FLUSH   PRIVILEGES;</p><p>如果你想允许用户myuser从ip为<code>192.168.1.3</code>的主机连接到mysql服务器的dk数据库，并使用mypassword作为密码</p><p>GRANT ALL PRIVILEGES ON dk.* TO ‘myuser‘@’192.168.1.3’ IDENTIFIED BY ‘mypassword’ WITH GRANT OPTION;</p><p>FLUSH   PRIVILEGES;</p><p>如果你想允许用户myuser从<code>局域网中某个ip</code>的主机连接到mysql服务器的数据库，并使用mypassword作为密码；你要使用%通配符比如你有192.168.0.* 和 192.168.1.* 两个网段,要两个网段都可以访问你要’192.168.%’， 只要一个可以访问可以向下面例子这样。</p><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘myuser‘@’192.168.1.%’ IDENTIFIED BY ‘mypassword’ WITH GRANT OPTION;<br>FLUSH   PRIVILEGES;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;＃报错:”Host ‘192.168.＊.＊’ is not allowed to connect to this MariaDB server”&lt;/p&gt;
&lt;p&gt;两种解决方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;改表法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”, 使得可以在远程访问到mysql。&lt;/p&gt;
&lt;p&gt;mysql -u root -pvmwaremysql&amp;gt;use mysql;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;update user set host = ‘%’ where user = ‘root’;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;select host, user from user;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt;FLUSH RIVILEGES&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="https://groupfusion.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mysql" scheme="https://groupfusion.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>sublime text3 快捷键</title>
    <link href="https://groupfusion.github.io/2017/06/23/tools/sublime_text3_%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://groupfusion.github.io/2017/06/23/tools/sublime_text3_%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2017-06-23T01:47:57.000Z</published>
    <updated>2023-12-15T12:46:22.921Z</updated>
    
    <content type="html"><![CDATA[<p>#sublime text3 快捷键</p><p>Sublime Text 是一款流行的文本编辑器软件，有点类似于TextMate，跨平台，可运行在Linux，Windows和Mac OS X。也是许多程序员喜欢使用的一款文本编辑器软件。本文将简单介绍 Sublime Text 3 的快捷键操作。</p><span id="more"></span><table><thead><tr><th align="center">快捷键分类</th><th align="left">功能说明</th><th align="left">mac</th><th align="left">win</th><th align="left">Linux</th></tr></thead><tbody><tr><td align="center">界面控制</td><td align="left">标签控制,前后标签切换</td><td align="left">cmd+alt+左右箭头</td><td align="left">NA</td><td align="left"></td></tr><tr><td align="center">搜索类</td><td align="left">在打开的文件中搜索关键字</td><td align="left">cmd+p</td><td align="left">ctrl+p</td><td align="left"></td></tr><tr><td align="center">搜索类</td><td align="left">一行接一行选择光标处相同的词，后续可以统一修改</td><td align="left">cmd+d</td><td align="left">ctrl+d</td><td align="left"></td></tr><tr><td align="center">搜索类</td><td align="left">一次性选中与光标处相同的全部词，统一修改</td><td align="left">cmd+ctrl+g</td><td align="left">alt+F3</td><td align="left"></td></tr><tr><td align="center">搜索类</td><td align="left">跳转到对应括号</td><td align="left">Ctrl+M</td><td align="left">Ctrl+M</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">按行选择</td><td align="left">cmd+l</td><td align="left">ctrl+l</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">选择光标出的词，或空格，同时标记上下文相同内容</td><td align="left">cmd+l</td><td align="left">ctrl+l</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">删除(剪切)当前行</td><td align="left">cmd+x</td><td align="left">Ctrl+X</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">删除当前行光标之后的字符</td><td align="left">cmd+K+K</td><td align="left">Ctrl+K+K</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">在当前行之前插入新行</td><td align="left">cmd+Shift+Enter</td><td align="left">Ctrl+Shift+Enter</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">在当前行之后插入新行</td><td align="left">cmd+Enter</td><td align="left">Ctrl+Enter</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">复制当前行并在插入</td><td align="left">cmd+shift+D</td><td align="left">ctrl+shift+D</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">上下移动行光标所在行</td><td align="left">cmd+ctrl+上下</td><td align="left">ctrl+shift+上下</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">* 多个光标（选择）</td><td align="left">cmd+alt+鼠标左键（拖动）</td><td align="left">NA</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">* 多个光标</td><td align="left">cmd + 需要放光标的位置鼠标左键</td><td align="left">ctrl+ 需要放光标的位置鼠标左键</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">光标定位：</td><td align="left">cmd+方向键 可定位光标到页面开始、结束，行开始、结束</td><td align="left"></td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">快速跳转到某一行</td><td align="left">ctrl＋G</td><td align="left"></td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">多行缩紧</td><td align="left">cmd＋] &amp; cmd+[</td><td align="left">ctrl＋] &amp; ctrl+[</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">转换为大写</td><td align="left">Cmd + K + U</td><td align="left">ctrl＋K + U</td><td align="left"></td></tr><tr><td align="center">编辑</td><td align="left">转换为小写</td><td align="left">Cmd + K + L</td><td align="left">ctrl＋K + L</td><td align="left"></td></tr></tbody></table><p>注：标＊的非常常用，尤其是在批量编辑和插入时。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;#sublime text3 快捷键&lt;/p&gt;
&lt;p&gt;Sublime Text 是一款流行的文本编辑器软件，有点类似于TextMate，跨平台，可运行在Linux，Windows和Mac OS X。也是许多程序员喜欢使用的一款文本编辑器软件。本文将简单介绍 Sublime Text 3 的快捷键操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工具" scheme="https://groupfusion.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>关于hibernate could not resolve property_ provinceId of 错误</title>
    <link href="https://groupfusion.github.io/2017/05/27/devlang/%E5%85%B3%E4%BA%8Ehibernate_could_not_resolve_property_provinceid_of_%E9%94%99%E8%AF%AF/"/>
    <id>https://groupfusion.github.io/2017/05/27/devlang/%E5%85%B3%E4%BA%8Ehibernate_could_not_resolve_property_provinceid_of_%E9%94%99%E8%AF%AF/</id>
    <published>2017-05-27T02:47:57.000Z</published>
    <updated>2023-12-15T12:42:47.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于hibernate-could-not-resolve-property-：-provinceId-of-错误"><a href="#关于hibernate-could-not-resolve-property-：-provinceId-of-错误" class="headerlink" title="关于hibernate could not resolve property ： provinceId of 错误"></a>关于hibernate could not resolve property ： provinceId of 错误</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.hibernate.QueryException: could not resolve property: provinceId of: com.petewell.assess.hb.model.HBExameResult</span><br></pre></td></tr></table></figure><p>这个错误是说，在ExameResult 中没有找到proviceId属性，通常情况下我们在ExameResult中添加相应的属性就可以了。<br>但此次报的错误没有你想象的那么简单，首先我的provinceId属性已经在BaseExameResult中定义。定义的关系如下：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//////////////////////</span><br><span class="line">//  BaseExameResult //     -----&gt; BaseExameResult.hbm.xml</span><br><span class="line">//////////////////////</span><br><span class="line">∆</span><br><span class="line">|</span><br><span class="line">//////////////////////</span><br><span class="line">//    HBExameResult   //     -----&gt; ExameResult.hbm.xml</span><br><span class="line">//////////////////////</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的这种情况下，hibernate查找映射关系时，会直接查找子类而不会找父类。那么我们这样实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">////////////////////////////</span><br><span class="line">//  BaseExameResult       //     -----&gt; BaseExameResult.hbm.xml</span><br><span class="line">////////////////////////////</span><br><span class="line">∆                   ∆               </span><br><span class="line">|                  |</span><br><span class="line">///////////////////     ///////////////////////</span><br><span class="line">HBExameResult.hbm.xml&lt;-// HBExameResult //     ///  CMExameResult   //--&gt; CMExameResult.hbm.xml</span><br><span class="line">///////////////////     //////////////////////</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;关于hibernate-could-not-resolve-property-：-provinceId-of-错误&quot;&gt;&lt;a href=&quot;#关于hibernate-could-not-resolve-property-：-provinceId-of-错误&quot; class=&quot;headerlink&quot; title=&quot;关于hibernate could not resolve property ： provinceId of 错误&quot;&gt;&lt;/a&gt;关于hibernate could not resolve property ： provinceId of 错误&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;org.hibernate.QueryException: could not resolve property: provinceId of: com.petewell.assess.hb.model.HBExameResult&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个错误是说，在ExameResult 中没有找到proviceId属性，通常情况下我们在ExameResult中添加相应的属性就可以了。&lt;br&gt;但此次报的错误没有你想象的那么简单，首先我的provinceId属性已经在BaseExameResult中定义。定义的关系如下：&lt;/p&gt;</summary>
    
    
    
    
    <category term="hibernate ORM" scheme="https://groupfusion.github.io/tags/hibernate-ORM/"/>
    
  </entry>
  
</feed>
